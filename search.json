[{"title":"Precise Zero-Shot Dense Retrieval without Relevance Labels","url":"/paper/Precise-Zero-Shot-Dense-Retrieval-without-Relevance-Labels/","content":"问题 (Problem)\n传统的密集检索（Dense Retrieval）系统严重依赖大规模的、人工标注的“查询-文档”相关性数据进行训练。然而，在许多新的或特定的领域中，获取这样的标注数据成本高昂、耗时巨大，甚至是不可能的。因此，如何在没有任何相关性标签（即“零样本”或“完全无监督”）的情况下，构建一个开箱即用且性能强大的密集检索系统，是一个核心的挑战。\n\n方法 (Methodology)\n为了解决上述问题，论文提出了 HyDE (Hypothetical Document Embeddings，假设性文档嵌入) 方法。其核心思想是绕过对“查询-文档”相关性的直接建模，而是将其分解为两个独立的、更容易处理的任务。\n工作流程图解 (Figure 1)\n\n该图清晰地展示了 HyDE 的两步流程：\n\n生成 (Generation)：用户的查询 (query) 首先与一个任务指令 (instruction) 相结合，然后被送入一个遵循指令的大语言模型（如 GPT）。该模型会生成一个“假设性”的文档，这个文档虽然内容可能是虚构的（包含幻觉），但它在语义和结构上捕捉了真实相关文档的特征。\n编码与检索 (Encoding &amp; Retrieval)：\n\n生成的假设性文档被输入到一个无监督的文本编码器 (如 Contriever)中，该编码器将其压缩成一个向量。这个向量被视为原始查询的“代理”。\n利用这个向量，系统在预先编码好的真实文档库中进行相似度搜索，最终召回最相似的真实文档 (real document)。\n\n\n\n核心数学公式\nHyDE 的方法规避了传统密集检索中直接计算 sim(q, d) 的难题。\n\n\n文档编码器 (Document Encoder)：\nHyDE 使用一个通过无监督对比学习预训练的编码器 f=encd=encconf = enc_{d} = enc_{con}f=encd​=enccon​ 来处理所有真实文档和假设性文档。\nvd=f(d)v_d = f(d)\nvd​=f(d)\n这个编码器 fff 的作用是将任何文档（真实的或假设的）映射到一个向量空间中。\n\n\n查询向量的构建 (Query Vector Construction)：\n查询向量 vqv_qvq​ 不是直接由查询 qqq 编码而来，而是通过对生成的假设性文档进行编码得到的。给定一个查询 qijq_{ij}qij​ 和一个指令 INSTiINST_iINSTi​，生成模型 ggg 会产出一个假设性文档。查询向量是所有可能生成的假设性文档编码向量的期望值。\nE[vqij]=E[f(g(qij,INSTi))]\\mathbb{E}[v_{q_{ij}}] = \\mathbb{E}[f(g(q_{ij}, INST_i))]\nE[vqij​​]=E[f(g(qij​,INSTi​))]\n\n\n期望的估计 (Estimating the Expectation)：\n在实践中，期望值通过从生成模型 ggg 中采样 N 个假设性文档 dk^\\hat{d_k}dk​^​，然后将它们的编码向量取平均来估计。\nv^qij≈1N∑k=1Nf(dk^)wheredk^∼g(qij,INSTi)\\hat{v}_{q_{ij}} \\approx \\frac{1}{N} \\sum_{k=1}^{N} f(\\hat{d_k}) \\quad \\text{where} \\quad \\hat{d_k} \\sim g(q_{ij}, INST_i)\nv^qij​​≈N1​k=1∑N​f(dk​^​)wheredk​^​∼g(qij​,INSTi​)\n论文中还考虑将原始查询本身也作为一个“假设”，与N个生成文档的向量一起平均，以增强稳健性。\nv^qij=1N+1[∑k=1Nf(dk^)+f(qij)]\\hat{v}_{q_{ij}} = \\frac{1}{N+1} \\left[ \\sum_{k=1}^{N}f(\\hat{d_k}) + f(q_{ij}) \\right]\nv^qij​​=N+11​[k=1∑N​f(dk​^​)+f(qij​)]\n\n\n最终检索 (Final Retrieval)：\n最后，用这个构建好的查询向量 v^qij\\hat{v}_{q_{ij}}v^qij​​ 与语料库中所有真实文档的向量 vdv_dvd​ 计算内积（相似度），并召回得分最高的文档。\nsim(qij,d)=⟨v^qij,vd⟩sim(q_{ij}, d) = \\langle \\hat{v}_{q_{ij}}, v_d \\rangle\nsim(qij​,d)=⟨v^qij​​,vd​⟩\n\n\n\n基线模型 (Baselines)\n论文将 HyDE 与多类基线模型进行了比较：\n\n无监督模型:\n\nBM25: 传统的基于词频的稀疏检索方法。\nContriever / mContriever: HyDE 所使用的底层无监督密集编码器，单独使用作为对比。\n\n\n有监督模型 (作为参考):\n\nDPR, ANCE: 在大规模数据集 MS MARCO 上训练的监督式密集检索模型。\nContriever-ft / mContriever-ft: 在 MS MARCO 上进行微调后的 Contriever 模型，代表了当前先进的监督式方法。\nmDPR, mBERT, XLM-R: 用于多语言任务比较的监督式模型。\n\n\n\n\n数据集 (Datasets)\n实验覆盖了多种任务和语言，以验证 HyDE 的通用性。\n\n网页搜索: TREC DL19 和 TREC DL20，两者都基于 MS MARCO 数据集。\n低资源检索 (BEIR  benchmark): 包含7个不同领域的任务，如 Scifact (科学事实核查), Arguana (论点检索), TREC-COVID (新冠科研文献), FiQA (金融问答), DBPedia (实体检索), TREC-NEWS (新闻检索) 和 Climate-Fever (气候变化事实核查)。\n多语言检索 (Mr.TyDi): 涵盖斯瓦希里语 (sw)、韩语 (ko)、日语 (ja) 和孟加拉语 (bn) 四种语言。\n\n\n可复现性 (Reproducibility)\n\n代码: 论文在首页明确指出其代码是开源的，并提供了 GitHub 链接。实验使用了 Pyserini 工具包进行检索。\n算力/模型:\n\n生成模型: 主要使用了 OpenAI 的 text-davinci-003 API。同时也测试了 Cohere (52B 参数) 和 FLAN-T5-xxl (11B 参数)。\n编码器模型: 使用了 Contriever (BERT-base, 110M 参数) 和 GTR-XL (T5-XL, 1.2B 参数)。\n论文附录中详细列出了所用模型的大小、来源和许可证信息。\n\n\n\n\n一个可改进的点\n指令的精细化与自适应 (Instruction Refinement and Adaptation)。\n论文在分析部分提到，在 FiQA（金融）和 DBPedia（实体）这两个任务上，HyDE 的性能与微调后的模型（Contriever-ft）差距较为明显。作者推测，这可能是因为用于这些任务的指令“欠指定”（under-specification）。他们认为，设计更精巧、更具针对性的指令（more elaborate prompts）可能会提升性能。\n这是一个非常直接的改进方向：\n\n可以研究如何根据查询的意图或领域，自动生成或选择最优的指令。例如，可以训练一个小模型来判断查询属于哪个领域（金融、科学、日常问答等），然后从一个预设的指令库中选择最匹配的指令模板。\n甚至可以探索让大语言模型本身来“反思”和“优化”指令。例如，可以先用一个通用指令生成假设性文档，然后分析其与检索结果的初步匹配情况，再让大语言模型根据该反馈，生成一个更精确的指令，进行第二轮检索。这可以使 HyDE 具备一定的自适应能力。\n\n","categories":["paper"],"tags":["paper","Retriever","zero-shot"]},{"title":"Maximum Flow","url":"/DataStru-Algo/Maximum-Flow/","content":"\n免责声明：code太难写了，本章就不提供code了，各位自行GPT吧（\n\n基本概念阐述\n问题阐述\n\n输入：一个有向有权图 G=(V,E)G=(V,E)G=(V,E) ，源节点 sss ，汇点 ttt​\n目标：从 sss 发送尽可能多的水到 ttt​\n约束：\n\n流要小于管道容量\n\n\n\n流网络和流\n\n\n流网络\n\nG=(V,E)G=(V,E)G=(V,E)​ 是一个有向有权图\n\n∣E∣≥∣V∣−1|E|\\ge |V|-1∣E∣≥∣V∣−1\n\n\n图中每一条边 (u,v)∈E(u,v)\\in E(u,v)∈E 有一个非负的容量值 c(u,v)≥0c(u,v)\\ge 0c(u,v)≥0\n\n若 (u,v)∉E(u,v)\\notin E(u,v)∈/E ，则定义 c(u,v)=0c(u,v)=0c(u,v)=0\n\n\n源节点 sss ，汇点 ttt\n\n\n\n流 flowflowflow\n\n\n在一个流网络 G=(V,E)G=(V,E)G=(V,E) 中，设容量函数为 ccc ，源节点 sss ，汇点 ttt\n\n\nGGG 中的流为一个实值函数 f:V×V→Rf:V \\times V \\to Rf:V×V→R ，满足以下两条性质​：\n\n容量限制：对于所有的节点，0≤f(u,v)≤c(u,v)0\\le f(u,v)\\le c(u,v)0≤f(u,v)≤c(u,v) ​\n流量守恒：对于除源节点、汇点外（V−{s,t}V-\\{s,t\\}V−{s,t}）的所有节点，∑v∈Vf(v,u)=∑v∈Vf(u,v)\\sum_{v \\in V}f(v,u)=\\sum_{v \\in V} f(u,v)∑v∈V​f(v,u)=∑v∈V​f(u,v)​\n\n即流入 uuu 的总流量等于从 uuu​ 流出的总流量\n前后两个 vvv 一般是不同的，所以我更倾向写成 ∑v∈Vf(v,u)=∑v′∈Vf(u,v′)\\sum_{v \\in V}f(v,u)=\\sum_{v&#x27; \\in V} f(u,v&#x27;)∑v∈V​f(v,u)=∑v′∈V​f(u,v′)\n当 (u,v)∉E(u,v)\\notin E(u,v)∈/E ，则 f(u,v)=0f(u,v)=0f(u,v)=0​\n\n\n\n\n\n一个流的值 ∣f∣|f|∣f∣ 定义为：\n∣f∣=∑v∈Vf(s,v)−∑v∈Vf(v,s)|f|=\\sum_{v\\in V}f(s,v)-\\sum_{v \\in V}f(v,s)\n∣f∣=v∈V∑​f(s,v)−v∈V∑​f(v,s)\n\n表示从源结点流入该节点的总流量减去流入源结点的总流量。\n一般而言，没有流入源节点的流，即第二项的值为 000​ ，所以也可以写成：\n\n\n\n∣f∣=∑v∈Vf(s,v)|f|=\\sum_{v\\in V}f(s,v)\n∣f∣=v∈V∑​f(s,v)\n\n\n\n\n\n\n残存网络 Residual GraphResidual\\ GraphResidual Graph​\n\n\n残存边 (u,v)(u,v)(u,v) ，残存容量 cf=c(u,v)−f(u,v)c_f=c(u,v)-f(u,v)cf​=c(u,v)−f(u,v)​​​\n回流边 (v,u)(v,u)(v,u) ，回流值大小 cf′=f′(v,u)=f(u,v)c_{f&#x27;}=f&#x27;(v,u)=f(u,v)cf′​=f′(v,u)=f(u,v) ——在 Ford−FulkersonFord-FulkersonFord−Fulkerson 方法里会用到\n\ncf′=∑f′(v,u)c_{f&#x27;}=\\sum f&#x27;(v,u)cf′​=∑f′(v,u) ，也即合并 MergeMergeMerge 操作，后面会给出证明\n\n\n\n增广路径 Augmenting pathsAugmenting\\ pathsAugmenting paths\n\n\n增广路径 ppp 是从源节点 sss 到汇点 ttt 的一条简单路径\n路径 ppp 的瓶颈容量 cf(p)=min{cf(u,v):(u,v)∈p}c_f(p)=min\\{c_f(u,v):(u,v)\\in p\\}cf​(p)=min{cf​(u,v):(u,v)∈p}​\n\n切割\n切割，字面意思，就是把图切割成 nnn 份。在本章中，我们主要讨论的是 S−T cut\\mathcal{S-T}\\ cutS−T cut ，即把图切割成两份。\n\n\nS−T cut\\mathcal{S-T}\\ cutS−T cut\n\n\n将节点集合 VVV 切割成两个子集：S\\mathcal{S}S 和 T\\mathcal{T}T​\n\nS∪T=V\\mathcal{S} \\cup \\mathcal{T}=VS∪T=V ，S∩T=∅\\mathcal{S} \\cap \\mathcal{T}=\\emptysetS∩T=∅\ns∈Ss \\in \\mathcal{S}s∈S ， t∈Tt \\in \\mathcal{T}t∈T​\n\n\n\nS\\mathcal{S}S 和 T\\mathcal{T}T 的二元组 (S,S)(\\mathcal{S},\\mathcal{S})(S,S) 被称为 S−T cut\\mathcal{S-T}\\ cutS−T cut​\n\n\n定义 S−T\\mathcal{S-T}S−T 的容量为离开集合 S\\mathcal{S}S​ 的边的权重之和，如下：\nc(S,T)=∑u∈S∑v∈Tc(u,v)c(\\mathcal{S},\\mathcal{T})=\\sum_{u \\in \\mathcal{S}}\\sum_{v \\in \\mathcal{T}}c(u,v)\nc(S,T)=u∈S∑​v∈T∑​c(u,v)\n\n例如下图的 c(S,T)=6c(\\mathcal{S},\\mathcal{T})=6c(S,T)=6\n\n\n\n定义切割的净流量 f(S,T)f(\\mathcal{S},\\mathcal{T})f(S,T) 如下：\nf(S,T)=∑u∈S∑v∈Tf(u,v)−∑u∈S∑v∈Tf(v,u)f(\\mathcal{S},\\mathcal{T})=\\sum_{u \\in \\mathcal{S}}\\sum_{v \\in \\mathcal{T}}f(u,v)-\\sum_{u \\in \\mathcal{S}}\\sum_{v \\in \\mathcal{T}}f(v,u)\nf(S,T)=u∈S∑​v∈T∑​f(u,v)−u∈S∑​v∈T∑​f(v,u)\n\n例如下图的 f(S,T)=f(v1,v3)+f(v1,v4)+f(v2,v4)−f(v4,s)=2+2+2−4=2f(\\mathcal{S},\\mathcal{T})=f(v_1,v_3)+f(v_1,v_4)+f(v_2,v_4)-f(v_4,s)=2+2+2-4=2f(S,T)=f(v1​,v3​)+f(v1​,v4​)+f(v2​,v4​)−f(v4​,s)=2+2+2−4=2\n\n\n\ne.g.\n\n\n \n     \n     \n \n\n注意，S−T cut\\mathcal{S-T}\\ cutS−T cut 不唯一\n\n \n     \n \n\n\n最小割 Min−CutMin-CutMin−Cut\n\n使容量最小化的切割被称为最小割 Min−CutMin-CutMin−Cut\ne.g.\n\n \n     \n     \n \n\n\nNaive AlgorithmNaive\\ AlgorithmNaive Algorithm 引入\n\nNaive 不是一个人名，它的意思是天真的；幼稚的。这里应译为朴素算法\n\n​\t这个算法是初步的算法，并不一定能找到最大流（只能找到阻塞流），只是大多数情况下可以找到最大流，但是这种方法很好理解，并且后面的更优的算法都是以此为基础进行优化的，所以我们先介绍这种算法。\n算法实现步骤\n\n创建一个残存图 (residual graph)(residual\\ graph)(residual graph) ，初始化残存容量\nwhilewhilewhile  可以找到增广路径 :\n\n找一条增广路径\n找出增广路径中的瓶颈容量 xxx\n更新这条增广路径上每一条边，cf=cf−xc_f=c_f-xcf​=cf​−x ，并删除饱和边\n\n\n\n图示\n\n\n初始化\n\n\n\n第一轮循环\n\n\n随便用什么遍历方法找到一条从 sss 到 ttt​​​ 的增广路径，找到瓶颈容量，更新这条路径上的每一条边\n  \n  \n  \n  \n\n\n此时有两条边的余量为0，说明这两条管道已经饱和了，于是把余量为0的边删除\n\n\n\n\n\n\n\n\n\n第二轮循环\n\n同样的操作\n\n\n\n\n\n\n\n\n\n第三轮循环\n\n同样的操作\n\n\n\n\n    \n    \n    \n\n\n循环结束\n\n用原始图减去最终的残存图，即可得到流量图\n实际流量可以从源节点 sss 去进行计算\n\n\n\n\n    \n    \n\n该简单算法局限性\n该算法在寻找路径的时候，如果找到的路径是错误的，则最终找到的有可能不是最大流\n\n    \n    \n\n\n\t\n\t\n\n\n    \n    \n\n\n阻塞流   blocking flowblocking\\ flowblocking flow\n\n\n如果从源节点 sss 到汇点 ttt ，不能找到更多的流汇入，则该流是阻塞流\n最大流是阻塞流\n\nFord−FulkersonFord-FulkersonFord−Fulkerson 算法\n​\t上面的简单算法一旦选择了 bad pathbad\\ pathbad path 后，不能修正，就只能找到阻塞流。\n​\t而下面我们介绍的算法，则是以上面的算法为基础进行优化的，Ford−FulkersonFord-FulkersonFord−Fulkerson 算法添加了回流这一步操作，假如选到了阻塞流，则可以进行回流修正，从而解决了问题。\n图示\n​\t我们以刚刚的基本算法的示例图来进行算法介绍\n\n依旧进行初始化\n\n\n    \n\n\n\n第一轮循环\n\n这三步和之前的 naive algorithmnaive\\ algorithmnaive algorithm​ 都是一样的，关键在于之后的一步\n\n  \n  \n  \n  \n \n - 在删除了饱和边之后，$Ford-Fulkerson\\ Algorithm$ 增加了一步回流法：画出该增广路径的回流边，即从 $t$ 到 $s$​ 的流向。并且这些回流边在下一轮选择路径试仍然可以被选中。\n- 为什么可以这么做？这样做对算法的正确性有无影响？这里先介绍完算法，后文会给出正确性证明。\n\n\n\n\n\n\n第二轮循环\n\n依旧如此，进行同样的操作\n\n  \n \t\n \t\n \t\n \n - 此时我们注意到：在 $v_1 \\to s$​ 这条路径，有两条回流边，此时我们很容易就会想到一个问题，这两条边，是否可以合并？\n    - 答案是肯定的，同样的，我们在算法正确性小节会给出证明\n    - 第二轮循环结束的图如下：\n \n\n\n第三轮循环\n\n第三轮循环即是刚刚简单算法失败的地方，我们来看 Ford−FulkersonFord-FulkersonFord−Fulkerson​ 算法是如何纠正的\n\n此图很清晰地说明了回流边的作用——给后面的纠错预留操作空间\n\n\n\n\n\n\n    \n    \n    \n    \n\n\n\n循环结束\n\n此时，图中没有从 sss 到 ttt​ 的路径了，于是算法终止。\n\n \n     \n \n\n因此，我们可以得到流量图，且该图的 Maximum FlowMaximum\\ FlowMaximum Flow 为 555 。\n\n \n     \n     \n \n\n\n算法实现步骤\n刚刚我们介绍了 Naive AlgorithmNaive\\ AlgorithmNaive Algorithm ，对于 Ford−FulkersonFord-FulkersonFord−Fulkerson 算法的步骤，也只需添加一句话：\n\n创建一个残存图 (residual graph)(residual\\ graph)(residual graph) ，初始化残存容量\nwhilewhilewhile  可以找到增广路径 :\n\n找一条增广路径\n找出增广路径中的瓶颈容量 xxx\n更新这条增广路径上每一条边，cf=cf−xc_f=c_f-xcf​=cf​−x​​ ，并删除饱和边\n==添加该增广路径的回流边==\n\n\n\n最坏时间复杂度分析\n\n\nwhilewhilewhile​​ 循环最坏情况\n​\t不难看出，该图的最大流为 200200200 ，若选择路径时，非常&quot;好运&quot;地选择了 s→v1→v2→ts \\to v_1 \\to v_2 \\to ts→v1​→v2​→t 这条路径，则会发生一些 amazingamazingamazing 的事情，即后面两张图。此时，循环就会进行 200200200 遍，即进行 Amount of MaxFlowAmount\\ of\\ MaxFlowAmount of MaxFlow 遍。\n\n\n\n    \n    \n    \n\n​\t\t以下给出证明：\n​\t\t\t由于每一轮循环中，流量值至少增加 111 ，FlowvalueFlowvalueFlowvalue 从 000 开始增长到 MaxFlowMaxFlowMaxFlow\n​\t\t\t所以，Iterations≤Amount of MaxFlowIterations \\le Amount\\ of\\ MaxFlowIterations≤Amount of MaxFlow\n​\t\t\t在这个例子中，Iterations=Amount of MaxFlowIterations = Amount\\ of\\ MaxFlowIterations=Amount of MaxFlow\n​\t\t综上所述，循环的次数为：O(f∗)O(f^*)O(f∗) ，其中 f∗f^*f∗ 代表最大流的大小。\n\n\n寻找路径最坏情况\n​\t假设有向图 GGG 中有 EEE 条边，VVV 个结点，并且所有的结点都至少有一条相邻边，则 E≥V2E \\ge \\frac{V}{2}E≥2V​\n​\t所以如果使用 bfsbfsbfs 或 dfsdfsdfs ，在一个残存网络中找到一条路径的时间可以化为：O(V+E′)=O(E)O(V+E&#x27;)=O(E)O(V+E′)=O(E)​\n\n\n最坏时间复杂度\n​\t综上所述，最坏时间复杂度为：O(Ef∗)O(Ef^*)O(Ef∗)​\n\n\n*算法正确性证明\n​\t在算法介绍中，我们得知了设置回流边的意义，现在，我们来探究为什么能设置回流边，以及我们对回流边所进行的操作，是否会对算法正确性有所影响。\n对于回流操作正确性的证明\n​\t我们知道，残存网络（residual graphresidual\\ graphresidual graph）是一个特殊的流网络，其允许反向边，也即平行边的存在。\n​\t那么对于残存网络中，这&quot;特殊&quot;的流 f′f&#x27;f′ ，我们定义 $f \\uparrow f’ $ 为流 f′f&#x27;f′ 对 fff 的递增操作，定义为：\n(f↑f′)(u,v)={f(u,v)+f′(u,v)−f′(v,u)若(u,v)∈E0其他(f\\uparrow f&#x27;)(u,v)=\\begin{cases}f(u,v)+f&#x27;(u,v)-f&#x27;(v,u) &amp;若(u,v)\\in E\n \\\\0 &amp;其他\n\\end{cases}\n(f↑f′)(u,v)={f(u,v)+f′(u,v)−f′(v,u)0​若(u,v)∈E其他​\n​\t在残存网络中将流量发送到反向边上等同于在原来的网络中缩减流量，所以将边 (u,v)(u,v)(u,v) 的流量增加 f′(u,v)f&#x27;(u,v)f′(u,v) ，但减少了 f′(v,u)f&#x27;(v,u)f′(v,u) 。在残存网络中，这种将流量推流回去也称为抵消操作（cancellationcancellationcancellation​）。\n​\n​\t对于上述操作，其满足容量限制性质以及流量守恒性质，证明如下：\n​\t\t先证明容量守恒性质，\n​\t\t\t设边 (u,v)∈E(u,v)\\in E(u,v)∈E ，则 cf(v,u)=f(u,v)c_f(v,u)=f(u,v)cf​(v,u)=f(u,v) ，且 f′(v,u)≤cf(v,u)=f(u,v)f&#x27;(v,u) \\le c_f(v,u)=f(u,v)f′(v,u)≤cf​(v,u)=f(u,v) ，因此有，\n(f↑f′)(u,v)=f(u,v)+f′(u,v)−f′(v,u)≥f(u,v)+f′(u,v)−f(u,v)=f′(u,v)≥0(f↑f′)(u,v)=f(u,v)+f′(u,v)−f′(v,u)≤f(u,v)+cf(u,v)=f(u,v)+c(u,v)−f(u,v)=c(u,v)\\begin{align*}\n(f \\uparrow f&#x27;)(u,v)\n&amp;=f(u,v)+f&#x27;(u,v)-f&#x27;(v,u)\\\\\n&amp;\\ge f(u,v)+f&#x27;(u,v)-f(u,v)\\\\\n&amp;=f&#x27;(u,v)\\\\\n&amp;\\ge 0\\\\\n\\\\\n(f \\uparrow f&#x27;)(u,v)\n&amp;=f(u,v)+f&#x27;(u,v)-f&#x27;(v,u)\\\\\n&amp;\\le f(u,v)+c_f(u,v)\\\\\n&amp;=f(u,v)+c(u,v)-f(u,v)\\\\\n&amp;=c(u,v)\n\\end{align*}\n(f↑f′)(u,v)(f↑f′)(u,v)​=f(u,v)+f′(u,v)−f′(v,u)≥f(u,v)+f′(u,v)−f(u,v)=f′(u,v)≥0=f(u,v)+f′(u,v)−f′(v,u)≤f(u,v)+cf​(u,v)=f(u,v)+c(u,v)−f(u,v)=c(u,v)​\n​\t\t\t所以，0≤(f↑f′)(u,v)≤c(u,v)0 \\le (f \\uparrow f&#x27;)(u,v) \\le c(u,v)0≤(f↑f′)(u,v)≤c(u,v) ，即该操作满足容量限制性质。\n​\t\t再证明流量守恒性质，\n​\t\t\t因为 fff 和 f′f&#x27;f′ 都遵循流量守恒性质，所以对于所有的节点 u∈V−{s,t}u \\in V-\\{s,t\\}u∈V−{s,t} ，有，\n∑v∈V(f↑f′)(u,v)=∑v∈V(f(u,v)+f′(u,v)−f′(v,u))=∑v∈Vf(u,v)+∑v∈Vf′(u,v)−∑v∈Vf′(v,u)=∑v∈Vf(v,u)+∑v∈Vf′(v,u)−∑v∈Vf′(u,v)=∑v∈V(f(v,u)+f′(v,u)−f′(u,v))=∑v∈V(f↑f′)(v,u)\\begin{align*}\n\\sum_{v \\in V}(f \\uparrow f&#x27;)(u,v)\n&amp;=\\sum_{v \\in V}(f(u,v)+f&#x27;(u,v)-f&#x27;(v,u))\\\\\n&amp;=\\sum_{v \\in V}f(u,v)+\\sum_{v \\in V}f&#x27;(u,v)-\\sum_{v \\in V}f&#x27;(v,u)\\\\\n&amp;=\\sum_{v \\in V}f(v,u)+\\sum_{v \\in V}f&#x27;(v,u)-\\sum_{v \\in V}f&#x27;(u,v)\\\\\n&amp;=\\sum_{v \\in V}(f(v,u)+f&#x27;(v,u)-f&#x27;(u,v))\\\\\n&amp;=\\sum_{v \\in V}(f \\uparrow f&#x27;)(v,u)\\\\\n\\end{align*}\nv∈V∑​(f↑f′)(u,v)​=v∈V∑​(f(u,v)+f′(u,v)−f′(v,u))=v∈V∑​f(u,v)+v∈V∑​f′(u,v)−v∈V∑​f′(v,u)=v∈V∑​f(v,u)+v∈V∑​f′(v,u)−v∈V∑​f′(u,v)=v∈V∑​(f(v,u)+f′(v,u)−f′(u,v))=v∈V∑​(f↑f′)(v,u)​\n​\t\t\t其中第二行推导到第三行使用了 fff 和 f′f&#x27;f′ 的流量守恒性质。\n​\t\t\t所以，∑v∈V(f↑f′)(u,v)=∑v∈V(f↑f′)(v,u)\\sum_{v \\in V}(f \\uparrow f&#x27;)(u,v)=\\sum_{v \\in V}(f \\uparrow f&#x27;)(v,u)∑v∈V​(f↑f′)(u,v)=∑v∈V​(f↑f′)(v,u)​ ，即该操作满足流量守恒性质。\n​\t\t因此，对于 f↑f′f\\uparrow f&#x27;f↑f′​ 这个操作，其满足容量限制性质以及流量守恒性质。\n​\t所以回流操作并不会影响到流的基本性质，所以这个操作是正确的。\n对于函数 ∣f↑f′∣|f \\uparrow f&#x27;|∣f↑f′∣ 值大小的证明\n​\t那么如果根据流的值的定义，不妨猜想 ∣f↑f′∣=∣f∣+∣f′∣|f \\uparrow f&#x27;|=|f|+|f&#x27;|∣f↑f′∣=∣f∣+∣f′∣​ ，证明如下：\n​\t\t根据定义，有：\n∣f↑f′∣=∑v∈V(f↑f′)(s,v)−∑v∈V(f↑f′)(v,s)|f \\uparrow f&#x27;|=\\sum_{v\\in V}(f \\uparrow f&#x27;)(s,v)-\\sum_{v \\in V}(f \\uparrow f&#x27;)(v,s)\n∣f↑f′∣=v∈V∑​(f↑f′)(s,v)−v∈V∑​(f↑f′)(v,s)\n​\t\t因为对于每个节点 v∈Vv \\in Vv∈V ，可以有边 (s,v)(s,v)(s,v) 或 (v,s)(v,s)(v,s) ，但是二者不允许同时存在。\n​\t\t因此我们定义 V1={v:(s,v)∈E}V_1=\\{v:(s,v) \\in E\\}V1​={v:(s,v)∈E} 为有边从源节点到达的节点集合，V2={v:(v,s)∈E}V_2=\\{v:(v,s) \\in E\\}V2​={v:(v,s)∈E} 为有边通往源节点的节点集合。我们有 V1∪V2⊆VV_1 \\cup V_2 \\subseteq VV1​∪V2​⊆V 且 V1∩V2=∅V_1 \\cap V_2 = \\emptysetV1​∩V2​=∅ 。\n​\t\t所以上式可化为：\n∣f↑f′∣=∑v∈V(f↑f′)(s,v)−∑v∈V(f↑f′)(v,s)=∑v∈V1(f↑f′)(s,v)−∑v∈V2(f↑f′)(v,s)=∑v∈V1(f(s,v)+f′(s,v)−f′(v,s))−∑v∈V2(f(v,s)+f′(v,s)−f′(s,v))=∑v∈V1f(s,v)+∑v∈V1f′(s,v)−∑v∈V1f′(v,s)−∑v∈V2f(v,s)−∑v∈V2f′(v,s)+∑v∈V2f′(s,v)=∑v∈V1f(s,v)−∑v∈V2f(v,s)+∑v∈V1∪V2f′(s,v)−∑v∈V1∪V2f′(v,s)\\begin{align*}\n|f \\uparrow f&#x27;|\n&amp;=\\sum_{v\\in V}(f \\uparrow f&#x27;)(s,v)-\\sum_{v \\in V}(f \\uparrow f&#x27;)(v,s)\\\\\n&amp;=\\sum_{v\\in V_1}(f \\uparrow f&#x27;)(s,v)-\\sum_{v \\in V_2}(f \\uparrow f&#x27;)(v,s)\\\\\n&amp;=\\sum_{v\\in V_1}(f(s,v)+f&#x27;(s,v)-f&#x27;(v,s))-\\sum_{v\\in V_2}(f(v,s)+f&#x27;(v,s)-f&#x27;(s,v))\\\\\n&amp;=\\sum_{v\\in V_1}f(s,v)+\\sum_{v\\in V_1}f&#x27;(s,v)-\\sum_{v\\in V_1}f&#x27;(v,s)-\\sum_{v\\in V_2}f(v,s)-\\sum_{v\\in V_2}f&#x27;(v,s)+\\sum_{v\\in V_2}f&#x27;(s,v)\\\\\n&amp;=\\sum_{v\\in V_1}f(s,v)-\\sum_{v\\in V_2}f(v,s)+\\sum_{v \\in V_1 \\cup V_2}f&#x27;(s,v)-\\sum_{v \\in V_1 \\cup V_2}f&#x27;(v,s)\\\\\n\\end{align*}\n∣f↑f′∣​=v∈V∑​(f↑f′)(s,v)−v∈V∑​(f↑f′)(v,s)=v∈V1​∑​(f↑f′)(s,v)−v∈V2​∑​(f↑f′)(v,s)=v∈V1​∑​(f(s,v)+f′(s,v)−f′(v,s))−v∈V2​∑​(f(v,s)+f′(v,s)−f′(s,v))=v∈V1​∑​f(s,v)+v∈V1​∑​f′(s,v)−v∈V1​∑​f′(v,s)−v∈V2​∑​f(v,s)−v∈V2​∑​f′(v,s)+v∈V2​∑​f′(s,v)=v∈V1​∑​f(s,v)−v∈V2​∑​f(v,s)+v∈V1​∪V2​∑​f′(s,v)−v∈V1​∪V2​∑​f′(v,s)​\n​\t\t又因为当 v∈V1v \\in V_1v∈V1​ 时，对于在集合 V2V_2V2​ 的边，vvv 对应的流 fff 为 000 ，即每一个额外的项都为 000 ，反之亦然。\n​\t\t所以可以将 V1,V2,V1∪V2V_1,V_2,V_1\\cup V_2V1​,V2​,V1​∪V2​ 扩展到整个节点范围 VVV 中。\n​\t\t因此：\n∣f↑f′∣=∑v∈V1f(s,v)−∑v∈V2f(v,s)+∑v∈V1∪V2f′(s,v)−∑v∈V1∪V2f′(v,s)=∑v∈Vf(s,v)−∑v∈Vf(v,s)+∑v∈Vf′(s,v)−∑v∈Vf′(v,s)=∣f∣+∣f′∣\\begin{align*}\n|f \\uparrow f&#x27;|\n&amp;=\\sum_{v\\in V_1}f(s,v)-\\sum_{v\\in V_2}f(v,s)+\\sum_{v \\in V_1 \\cup V_2}f&#x27;(s,v)-\\sum_{v \\in V_1 \\cup V_2}f&#x27;(v,s)\\\\\n&amp;=\\sum_{v\\in V}f(s,v)-\\sum_{v\\in V}f(v,s)+\\sum_{v \\in V}f&#x27;(s,v)-\\sum_{v \\in V}f&#x27;(v,s)\\\\\n&amp;=|f|+|f&#x27;|\\\\\n\\end{align*}\n∣f↑f′∣​=v∈V1​∑​f(s,v)−v∈V2​∑​f(v,s)+v∈V1​∪V2​∑​f′(s,v)−v∈V1​∪V2​∑​f′(v,s)=v∈V∑​f(s,v)−v∈V∑​f(v,s)+v∈V∑​f′(s,v)−v∈V∑​f′(v,s)=∣f∣+∣f′∣​\n​\t\t即：∣f↑f′∣=∣f∣+∣f′∣|f \\uparrow f&#x27;|=|f|+|f&#x27;|∣f↑f′∣=∣f∣+∣f′∣\n对于合并操作正确性的证明\n​\t我们设 G=(V,E)G=(V,E)G=(V,E) 为一个流网络，设 fff 为 GGG 中的一个流，设 ppp 为残存网络 GfG_fGf​ 中的一条增广路径。假定将 fff 增加 fpf_pfp​ 的量，则函数 f↑fpf \\uparrow f_pf↑fp​ 是图 GGG 中的一个流，由上述证明可知其值为 ∣f↑fp∣=∣f∣+∣fp∣|f \\uparrow f_p|=|f|+|f_p|∣f↑fp​∣=∣f∣+∣fp​∣ 。\n​\t又因为合并的操作视为 ∣fp1↑fp2∣|f_{p_1} \\uparrow f_{p_2}|∣fp1​​↑fp2​​∣ ，所以合并后的值为 ∣fp1↑fp2∣=∣fp1∣+∣fp2∣|f_{p_1} \\uparrow f_{p_2}|=|f_{p_1}|+|f_{p_2}|∣fp1​​↑fp2​​∣=∣fp1​​∣+∣fp2​​∣ ，即合并操作是合理的。\n最大流最小切割定理的证明\n​\t上述证明解释了为什么我们可以进行回流、合并（MergeMergeMerge） 这些操作。那么接下来，我们来证明为什么最后得到的流一定是最大流。该证明也是对最大流最小切割定理的证明。\n前置证明准备\n​\t我们首先证明对于网络中的一个流以及任意切割 (S,T)(\\mathcal{S},\\mathcal{T})(S,T) ，其净流量 f(S,T)=∣f∣f(\\mathcal{S},\\mathcal{T})=|f|f(S,T)=∣f∣ ：\n​\t\t对于任意节点 u∈V−{s,t}u \\in V-\\{s,t\\}u∈V−{s,t} ，其流量守恒定律可改写成：\n∑v∈Vf(v,u)−∑v∈Vf(u,v)=0①\\sum_{v \\in V}f(v,u)-\\sum_{v \\in V} f(u,v)=0 \\quad\\quad①\nv∈V∑​f(v,u)−v∈V∑​f(u,v)=0①\n​\t\t根据 ∣f∣|f|∣f∣ 的定义：∣f∣=∑v∈Vf(s,v)−∑v∈Vf(v,s)|f|=\\sum_{v\\in V}f(s,v)-\\sum_{v \\in V}f(v,s)∣f∣=∑v∈V​f(s,v)−∑v∈V​f(v,s) ，我们得到：\n∣f∣=∑v∈Vf(s,v)−∑v∈Vf(v,s)②|f|=\\sum_{v\\in V}f(s,v)-\\sum_{v \\in V}f(v,s) \\quad\\quad②\n∣f∣=v∈V∑​f(s,v)−v∈V∑​f(v,s)②\n​\t\t将 ①①① 式针对所有节点 S−{s}\\mathcal{S}-\\{s\\}S−{s} 求和并加到 ②②② 中，得到：\n∣f∣=∑v∈Vf(s,v)−∑v∈Vf(v,s)+∑v∈S−{s}(∑v∈Vf(u,v)−∑v∈Vf(v,u))=∑v∈Vf(s,v)−∑v∈Vf(v,s)+∑v∈S−{s}∑v∈Vf(u,v)−∑v∈S−{s}∑v∈Vf(v,u)=∑v∈V(f(s,v)+∑v∈S−{s}f(u,v))−∑v∈V(f(v,s)+∑v∈S−{s}f(v,u))=∑v∈V∑u∈Sf(u,v)−∑v∈V∑u∈Sf(v,u)\\begin{align*}\n|f|\n&amp;=\\sum_{v\\in V}f(s,v)-\\sum_{v \\in V}f(v,s)+\\sum_{v \\in \\mathcal{S}-\\{s\\}}(\\sum_{v\\in V}f(u,v)-\\sum_{v \\in V}f(v,u))\\\\\n&amp;=\\sum_{v\\in V}f(s,v)-\\sum_{v \\in V}f(v,s)+\\sum_{v \\in \\mathcal{S}-\\{s\\}}\\sum_{v\\in V}f(u,v)-\\sum_{v \\in \\mathcal{S}-\\{s\\}}\\sum_{v \\in V}f(v,u)\\\\\n&amp;=\\sum_{v\\in V}(f(s,v)+\\sum_{v \\in \\mathcal{S}-\\{s\\}}f(u,v))-\\sum_{v \\in V}(f(v,s)+\\sum_{v \\in \\mathcal{S}-\\{s\\}}f(v,u))\\\\\n&amp;=\\sum_{v\\in V}\\sum_{u \\in \\mathcal{S}}f(u,v)-\\sum_{v\\in V}\\sum_{u \\in \\mathcal{S}}f(v,u)\n\\end{align*}\n∣f∣​=v∈V∑​f(s,v)−v∈V∑​f(v,s)+v∈S−{s}∑​(v∈V∑​f(u,v)−v∈V∑​f(v,u))=v∈V∑​f(s,v)−v∈V∑​f(v,s)+v∈S−{s}∑​v∈V∑​f(u,v)−v∈S−{s}∑​v∈V∑​f(v,u)=v∈V∑​(f(s,v)+v∈S−{s}∑​f(u,v))−v∈V∑​(f(v,s)+v∈S−{s}∑​f(v,u))=v∈V∑​u∈S∑​f(u,v)−v∈V∑​u∈S∑​f(v,u)​\n​\t\t又因为 V=S∪TV=\\mathcal{S}\\cup\\mathcal{T}V=S∪T 并且 S∩T=∅\\mathcal{S} \\cap \\mathcal{T}=\\emptysetS∩T=∅ ，所以可以将上式的 VVV 进行分解，即：\n∣f∣=∑v∈V∑u∈Sf(u,v)−∑v∈V∑u∈Sf(v,u)=∑v∈S∑u∈Sf(u,v)−∑v∈S∑u∈Sf(v,u)+∑v∈T∑u∈Sf(u,v)−∑v∈T∑u∈Sf(v,u)=∑v∈T∑u∈Sf(u,v)−∑v∈T∑u∈Sf(v,u)+(∑v∈S∑u∈Sf(u,v)−∑v∈S∑u∈Sf(v,u))\\begin{align*}\n|f|\n&amp;=\\sum_{v\\in V}\\sum_{u \\in \\mathcal{S}}f(u,v)-\\sum_{v\\in V}\\sum_{u \\in \\mathcal{S}}f(v,u)\\\\\n&amp;=\\sum_{v\\in \\mathcal{S}}\\sum_{u \\in \\mathcal{S}}f(u,v)-\\sum_{v\\in \\mathcal{S}}\\sum_{u \\in \\mathcal{S}}f(v,u)+\\sum_{v\\in \\mathcal{T}}\\sum_{u \\in \\mathcal{S}}f(u,v)-\\sum_{v\\in \\mathcal{T}}\\sum_{u \\in \\mathcal{S}}f(v,u)\\\\\n&amp;=\\sum_{v\\in \\mathcal{T}}\\sum_{u \\in \\mathcal{S}}f(u,v)-\\sum_{v\\in \\mathcal{T}}\\sum_{u \\in \\mathcal{S}}f(v,u)+(\\sum_{v\\in \\mathcal{S}}\\sum_{u \\in \\mathcal{S}}f(u,v)-\\sum_{v\\in \\mathcal{S}}\\sum_{u \\in \\mathcal{S}}f(v,u))\\\\\n\\end{align*}\n∣f∣​=v∈V∑​u∈S∑​f(u,v)−v∈V∑​u∈S∑​f(v,u)=v∈S∑​u∈S∑​f(u,v)−v∈S∑​u∈S∑​f(v,u)+v∈T∑​u∈S∑​f(u,v)−v∈T∑​u∈S∑​f(v,u)=v∈T∑​u∈S∑​f(u,v)−v∈T∑​u∈S∑​f(v,u)+(v∈S∑​u∈S∑​f(u,v)−v∈S∑​u∈S∑​f(v,u))​\n​\t\t不难看出，上式括号内的两个求和项是一样的，所以有：\n∣f∣=∑v∈T∑u∈Sf(u,v)−∑v∈T∑u∈Sf(v,u)=f(S,T)|f|=\\sum_{v\\in \\mathcal{T}}\\sum_{u \\in \\mathcal{S}}f(u,v)-\\sum_{v\\in \\mathcal{T}}\\sum_{u \\in \\mathcal{S}}f(v,u)=f(\\mathcal{S},\\mathcal{T})\n∣f∣=v∈T∑​u∈S∑​f(u,v)−v∈T∑​u∈S∑​f(v,u)=f(S,T)\n​\t综上，净流量 f(S,T)=∣f∣f(\\mathcal{S},\\mathcal{T})=|f|f(S,T)=∣f∣​ 。\n​\t由这个性质，我们可以得到一个引理：∣f∣≤c(S,T)|f| \\le c(\\mathcal{S},\\mathcal{T})∣f∣≤c(S,T) ，证明如下：\n∣f∣=f(S,T)=∑v∈T∑u∈Sf(u,v)−∑v∈T∑u∈Sf(v,u)≤∑v∈T∑u∈Sf(u,v)≤∑v∈T∑u∈Sc(u,v)=c(S,T)\\begin{align*}\n|f|\n&amp;=f(\\mathcal{S},\\mathcal{T})=\\sum_{v\\in \\mathcal{T}}\\sum_{u \\in \\mathcal{S}}f(u,v)-\\sum_{v\\in \\mathcal{T}}\\sum_{u \\in \\mathcal{S}}f(v,u)\\\\\n&amp;\\le \\sum_{v\\in \\mathcal{T}}\\sum_{u \\in \\mathcal{S}}f(u,v) \\le \\sum_{v\\in \\mathcal{T}}\\sum_{u \\in \\mathcal{S}}c(u,v) = c(\\mathcal{S},\\mathcal{T})\n\\end{align*}\n∣f∣​=f(S,T)=v∈T∑​u∈S∑​f(u,v)−v∈T∑​u∈S∑​f(v,u)≤v∈T∑​u∈S∑​f(u,v)≤v∈T∑​u∈S∑​c(u,v)=c(S,T)​\n​\t这个引理给出的一个直接结论就是：一个流网络中最大流的值不能超过该网络最小切割的容量。\n最大流最小切割定理\n​\t那么接下来，我们就来证明最大流最小切割原理。该原理表明一个最大流的值等于一个最小切割的容量。\n​\t最大流最小切割定理：\n​\t\t(1)(1)(1) fff 是 GGG 的一个最大流\n​\t\t(2)(2)(2) 残存网络 GfG_fGf​ 不包括任何增广路径\n​\t\t(3)(3)(3) ∣f∣=c(S,T)|f|=c(\\mathcal{S},\\mathcal{T})∣f∣=c(S,T) ，其中 (S,T)(\\mathcal{S},\\mathcal{T})(S,T) 是流网络 GGG 的某个切割。即 ∣f∣max=cmin(S,T)|f|_{max}=c_{min}(\\mathcal{S},\\mathcal{T})∣f∣max​=cmin​(S,T)\n​\t\t上述的三个条件是等效的，即三个条件互为充要条件。\n​\t以下是最大流最小切割定理的证明：\n​\t\t证 (1)→(2)(1) \\to (2)(1)→(2) ：\n​\t\t\t假设 fff 是 GGG 的一个最大流，但残存网络 GfG_fGf​ 同时存在一条增广路径 ppp 。如果我们对 fff 增加流量 fpf_pfp​ ，那么 ∣f↑fp∣=∣f∣+∣fp∣&gt;∣f∣|f \\uparrow f_p|=|f|+|f_p| &gt; |f|∣f↑fp​∣=∣f∣+∣fp​∣&gt;∣f∣ ，与 fff 是最大流矛盾。\n​\t\t证 (2)→(3)(2) \\to (3)(2)→(3) ：\n​\t\t\t对于节点 u∈Su \\in \\mathcal{S}u∈S 和 v∈Tv \\in \\mathcal{T}v∈T ，如果边 (u,v)∈E(u,v) \\in E(u,v)∈E ，则必有 f(u,v)=c(u,v)f(u,v)=c(u,v)f(u,v)=c(u,v) ，否则 (u,v)∈Ef(u,v) \\in E_f(u,v)∈Ef​ ，上述操作会将 vvv 置于集合 S\\mathcal{S}S 中。如果边 (v,u)∈E(v,u) \\in E(v,u)∈E ，则必有 f(v,u)=0f(v,u)=0f(v,u)=0 ，否则 cf(u,v)=f(v,u)c_f(u,v)=f(v,u)cf​(u,v)=f(v,u) 将为正值，边 (u,v)(u,v)(u,v) 将属于 EfE_fEf​ ，上述操作会将节点 vvv 置于集合 S\\mathcal{S}S 中。当边 (u,v)(u,v)(u,v) 和 (v,u)(v,u)(v,u) 都不在 EEE 中，则 f(u,v)=f(v,u)=0f(u,v)=f(v,u)=0f(u,v)=f(v,u)=0 。因此：\nf(S,T)=∑v∈T∑u∈Sf(u,v)−∑v∈T∑u∈Sf(v,u)=∑v∈T∑u∈Sc(u,v)−∑v∈T∑u∈S0=c(S,T)f(\\mathcal{S},\\mathcal{T})=\\sum_{v\\in \\mathcal{T}}\\sum_{u \\in \\mathcal{S}}f(u,v)-\\sum_{v\\in \\mathcal{T}}\\sum_{u \\in \\mathcal{S}}f(v,u)=\\sum_{v\\in \\mathcal{T}}\\sum_{u \\in \\mathcal{S}}c(u,v)-\\sum_{v\\in \\mathcal{T}}\\sum_{u \\in \\mathcal{S}}0=c(\\mathcal{S},\\mathcal{T})\nf(S,T)=v∈T∑​u∈S∑​f(u,v)−v∈T∑​u∈S∑​f(v,u)=v∈T∑​u∈S∑​c(u,v)−v∈T∑​u∈S∑​0=c(S,T)\n​\t\t证 (3)→(1)(3) \\to (1)(3)→(1) ：\n​\t\t\t由 ∣f∣≤c(S,T)|f| \\le c(\\mathcal{S},\\mathcal{T})∣f∣≤c(S,T) 即可说明 fff​ 是一个最大流,。\n​\t综上所述，Ford−FulkersonFord-FulkersonFord−Fulkerson 算法是正确的。\nEdmonds−KarpEdmonds-KarpEdmonds−Karp​ 算法\n​\t简单来说，Edmonds−KarpEdmonds-KarpEdmonds−Karp 算法是 Ford−FulkersonFord-FulkersonFord−Fulkerson 算法的一种特殊情况，全部流程跟 Ford−FulkersonFord-FulkersonFord−Fulkerson 算法基本一致。\n​\t唯一的区别是 Edmonds−KarpEdmonds-KarpEdmonds−Karp 算法在寻找增广路径中，使用寻找无权图最短路径的算法，在残存网络中将所有边的权值视为 111​ ，由此来寻找从源节点到汇点的最短路径。\n算法实现步骤\n参照 Ford−FulkersonFord-FulkersonFord−Fulkerson 算法的步骤，对于 Edmonds−KarpEdmonds-KarpEdmonds−Karp 算法的实现步骤只需修改一句话：\n\n创建一个残存图 (residual graph)(residual\\ graph)(residual graph) ，初始化残存容量\nwhilewhilewhile  可以找到增广路径 :\n\n==找到最短的增广路径==\n找出增广路径中的瓶颈容量 xxx\n更新这条增广路径上每一条边，cf=cf−xc_f=c_f-xcf​=cf​−x​​ ，并删除饱和边\n添加该增广路径的回流边\n\n\n\n时间复杂度分析\n对于寻找最短的增广路径，我们可以使用类 BFSBFSBFS 的算法。\n因此寻找最短路径的时间复杂度为：O(V+E)=O(E)O(V+E)=O(E)O(V+E)=O(E)​\n然后循环最多实现 O(VE)O(VE)O(VE) 次~~（这里就不证明了吧 详细证明看算法导论）~~\n因此时间复杂度为：O(VE2)O(VE^2)O(VE2)\n*DinicDinicDinic 算法\n​\t下面我们来介绍一个时间复杂度更低，达到了 O(V2E)O(V^2E)O(V2E) 的算法—— DinicDinicDinic 算法。\nLevel GraphLevel\\ GraphLevel Graph ​\n​\tDinicDinicDinic 算法需要用到一个新东西：Level GraphLevel\\ GraphLevel Graph 。Level GraphLevel\\ GraphLevel Graph 基于 BFSBFSBFS 实现，是一个有权无向图。其随着层数记录每一层的节点，最终到达汇点 ttt 。\n\ne.g.\n\n\n    \n    \n\n算法实现步骤\n该算法的实现与 Ford−FulkersonFord-FulkersonFord−Fulkerson 算法类似，但在操作中，我们主要以 Level GraphLevel\\ GraphLevel Graph 为主要操作对象：\n\n创建一个残存图 (residual graph)(residual\\ graph)(residual graph)​ ，初始化残存容量\nwhilewhilewhile 可以找到阻塞流：\n\n用残存图创建 level graphlevel\\ graphlevel graph\n在 level graphlevel\\ graphlevel graph 中找到阻塞流\n更新残存图，并添加反向边\n\n\n\n图示\n\n初始化\n\n\n\n\n第一次循环\n\n根据残存图创建 level graphlevel\\ graphlevel graph\n\n \n     \n     \n \n\n找到阻塞流，更新残存图\n\n \n     \n     \n     \n \n\n\n第二次循环\n\n根据上一次的结果，创建新的 level graphlevel\\ graphlevel graph\n\n \n     \n     \n \n\n在 level graphlevel\\ graphlevel graph​ 中找到阻塞流，更新残存图\n\n \n     \n     \n     \n \n\n\n第三轮循环\n\n根据上一次的结果，创建新的 level graphlevel\\ graphlevel graph\n\n \n     \n     \n \n\n因为没有边能到汇点 ttt ，循环终止，最终结果如下：\n\n \n     \n     \n \n\n\n时间复杂度\n时间复杂度为：O(V2E)O(V^2E)O(V2E)\n\n若图为一个链表时，有 nnn 层，循环最多为 O(V−1)O(V-1)O(V−1) 轮\n每一轮的时间为 O(VE)O(VE)O(VE)\n\n二部图问题\n\n嘛~有时间在做吧awa 反正是最大流之后的一章(4th edition)\n\n参考文献\n\nWang, Shusen. (n.d.). AdvancedAlgorithms. GitHub. Retrieved April 5, 2022, from https://github.com/wangshusen/AdvancedAlgorithms\nCormen, T. H., Leiserson, C. E., Rivest, R. L., &amp; Stein, C. (2009). 算法导论 (第三版). 机械工业出版社.\nCormen, T. H., Leiserson, C. E., Rivest, R. L., &amp; Stein, C. (2022). Introduction to Algorithms (4th ed.). MIT Press.\n\n","categories":["DataStru&Algo"],"tags":["Data Structure","Algorithm","SCNU Turing Discussion","Maximum Flow","Graph"]},{"title":"RAG for Knowledge-Intensive NLP Tasks","url":"/paper/RAG-for-Knowledge-Intensive-NLP-Tasks/","content":"1. 摘要与引言 (Abstract &amp; Introduction)\n\n\n核心问题: 大型预训练语言模型（如BART, T5）虽然在参数中存储了大量事实知识，但在知识的精确访问和操作上能力有限 。它们无法轻易扩展或修正知识，其决策过程缺乏透明度，并且可能产生“幻觉”（即捏造事实）。\n\n\n解决方案: 提出一种名为 RAG (Retrieval-Augmented Generation) 的通用模型框架，它将预训练的参数化记忆（一个seq2seq模型）与非参数化记忆（一个可通过神经检索器访问的密集向量索引，如维基百科）相结合 。\n\n\n模型构成: RAG模型包含一个预训练的seq2seq生成器（BART）和一个预训练的密集段落检索器（DPR）。\n\n\n主要贡献:\n\n\n在三个开放域问答任务上取得了最先进的（SOTA）成果 。\n\n\n在语言生成任务上，RAG比纯参数化模型生成的内容更具体、更多样、更符合事实 。\n\n\n展示了通过替换非参数化记忆（文档索引）来有效更新模型世界知识的能力 。\n\n\n\n\n\n2. 方法 (Methods)\n\n\n整体架构 (Figure 1):\n\n\n\n输入查询 (x) 进入 查询编码器 (Query Encoder) 生成查询向量 q(x) 。\n\n\n使用 最大内积搜索 (MIPS) 在 文档索引 (Document Index) 中检索与 q(x) 最相关的Top-K个文档 z 。\n\n\n生成器 (Generator) 将原始输入 x 和检索到的文档 z 结合起来，生成最终输出 y 。\n\n\n整个过程通过端到端训练，同时优化生成器和查询编码器 。\n\n\n\n\nRAG的两种模型:\n\n\nRAG-Sequence: 模型为整个输出序列选择同一个检索文档 z 。其概率模型是对不同文档 z 生成完整序列 y 的概率进行加权求和 。\n\n公式:\np(y∣x)≈∑z∈top−k(p(⋅∣x))pη(z∣x)pθ(y∣x,z)=∑z∈top−k(p(⋅∣x))pη(z∣x)Πi=1Npθ(yi∣x,z,y1:i−1)p(y|x) \\approx \\sum_{z \\in top-k(p(·|x))} p_\\eta(z|x)p_\\theta(y|x,z) = \\sum_{z \\in top-k(p(·|x))} p_\\eta(z|x)\\Pi_{i=1}^{N}p_\\theta(y_i|x,z,y_{1:i−1})p(y∣x)≈∑z∈top−k(p(⋅∣x))​pη​(z∣x)pθ​(y∣x,z)=∑z∈top−k(p(⋅∣x))​pη​(z∣x)Πi=1N​pθ​(yi​∣x,z,y1:i−1​)\n\n\n\nRAG-Token: 模型在生成每一个目标词元 (token) 时，都可以从多个文档中汲取信息 。其概率模型是在生成每个词元时，都对所有Top-K文档的贡献进行一次加权求和，然后将每一步的概率连乘 。\n\n公式:\np(y∣x)≈Πi=1N∑z∈top−(p(⋅∣x))kpη(z∣x)pθ(yi∣x,z,y1:i−1)p(y|x) \\approx \\Pi_{i=1}^{N} \\sum_{z∈top-(p(·|x))k}p_\\eta(z|x)p_\\theta(y_i|x,z,y_{1:i−1})p(y∣x)≈Πi=1N​∑z∈top−(p(⋅∣x))k​pη​(z∣x)pθ​(yi​∣x,z,y1:i−1​)\n\n\n\n\n\n核心组件:\n\n\n检索器 (Retriever): 基于DPR（Dense Passage Retriever），它包含一个BERT-base的查询编码器和文档编码器。\n\n\n生成器 (Generator): 使用BART-large，一个拥有4亿参数的预训练seq2seq模型。检索到的文档内容与原始输入被简单地拼接在一起送入BART。\n\n\n非参数化记忆: 使用2018年12月的维基百科快照，分割成2100万个100词的文档块。\n\n\n\n\n训练与解码:\n\n\n训练: 联合训练查询编码器和生成器，但保持文档编码器（和索引）固定以降低计算成本。\n\n\n解码: RAG-Token可以直接使用标准beam search解码 。RAG-Sequence需要为每个检索到的文档分别运行beam search，然后对生成的候选集进行边缘化概率计算，有&quot;Thorough Decoding&quot;和&quot;Fast Decoding&quot;两种方式。\n\n\n\n\n\n3. 实验与结果 (Experiments &amp; Results)\n\n\n开放域问答 (Open-domain QA):\n\n\n在Natural Questions (NQ), WebQuestions (WQ), 和 CuratedTrec (CT) 数据集上，RAG均取得了SOTA成绩。\n\n\nRAG-Sequence在TQA数据集上也超过了T5-11B+SSM。\n\n\n即使正确答案未出现在任何检索到的文档中，RAG仍能在NQ上实现11.8%的准确率，这是纯抽取式模型无法做到的。\n\n\n\n\n生成任务 (Generation Tasks):\n\n\nMS-MARCO: RAG-Sequence在Bleu和Rouge-L指标上均优于BART基线。\n\n\nJeopardy问题生成: RAG-Token在Q-BLEU-1指标上表现最佳。\n人工评估显示，RAG的生成结果在事实性 (42.7% vs 7.1%) 和具体性 (37.4% vs 16.8%) 上远超BART。\n\n\n多样性: RAG的生成结果比BART更多样化，其中RAG-Sequence的多样性最高。\n\n\n\n\n事实核查 (Fact Verification):\n\n\n在FEVER任务中，RAG在未接收任何检索监督信号的情况下，其准确率与经过复杂设计的SOTA模型差距在4.3%以内。\n\n\nRAG检索到的Top-10文档中有90%的概率包含FEVER任务中的黄金标准证据文章。\n\n\n\n\n核心能力分析:\n\n\n知识更新 (Hot-swapping): 实验证明，通过切换2016年和2018年的维基百科索引，RAG能正确回答相应年份的问题，证明了其知识可以被轻松更新。\n\n\n记忆协同: 通过分析生成过程，发现检索的非参数化记忆可以引导并“触发”生成器的参数化记忆，使其生成存储在内部的特定知识（如书名。\n\n\n可学习的检索: 消融实验表明，对查询编码器进行微调（Learned Retrieval）对于大多数任务的性能至关重要，尤其是在开放域问答上。\n\n\n\n\n\n4. 讨论与影响 (Discussion &amp; Broader Impact)\n\n\n总结: RAG成功地将参数化和非参数化记忆结合，在知识密集型任务上表现出色，生成的文本更真实、更具体，并且知识易于更新。\n\n\n社会效益: RAG更强地根植于事实知识，能减少“幻觉”，提供更好的可解释性和可控性。\n\n\n潜在风险: 与其他大型语言模型类似，RAG也可能被用于生成误导性内容或垃圾邮件。但其事实性 grounding 可以在一定程度上缓解此问题。\n\n\n","categories":["paper"],"tags":["paper","RAG","NLP"]},{"title":"Tree","url":"/DataStru-Algo/Tree/","content":"SCNU-Turing-Class CLRS Discussion Week4-5\n\n\nCiallo～(∠・ω&lt;)⌒★！Ciallo～(∠・ω&lt; )⌒★！Ciallo～(∠・ω&lt;)⌒★！​\n​右子树就是柚子树\n​柚子厨蒸鹅心\nCiallo～(∠・ω&lt;)⌒★！Ciallo～(∠・ω&lt; )⌒★！Ciallo～(∠・ω&lt;)⌒★！\n\n二叉树 Binary Tree\n二叉树的定义\n​一种非线性数据结构，代表“祖先”与“后代”之间的派生关系，体现了“一分为二”的分治逻辑。\n​每个节点包含的属性有：\n1. left指针，指向左子节点\n2. right指针，指向右子节点\n3. prev指针，指向父节点（书上这么写的，但实际构建可能不写这个。当然可以构建一个prev指针指向父节点，形成一个双向二叉树）\n4. key关键字，节点的值\n构建代码如下：\n//c++struct TreeNode &#123;    int val;          // 节点值    TreeNode *left;   // 左子节点指针    TreeNode *right;  // 右子节点指针    TreeNode *prev;   // 父节点指针    TreeNode(int x) : val(x), left(nullptr), right(nullptr), prev(nullptr) &#123;&#125;&#125;;\n二叉树常用术语\n\n「根节点 root noderoot\\ noderoot node 」：位于二叉树顶层的节点，没有父节点。\n「叶节点 leaf nodeleaf\\ nodeleaf node 」：没有子节点的节点，其两个指针均指向 None 。\n节点的「度 degreedegreedegree 」：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。\n二叉树的「高度 heightheightheight 」：从根节点到最远叶节点所经过的边的数量。\n节点的「深度 depthdepthdepth 」：从根节点到该节点所经过的边的数量。\n节点的「高度 heightheightheight 」：从距离该节点最远的叶节点到该节点所经过的边的数量。\n\n常见二叉树类型\n\n\n完美二叉树 perfect binary treeperfect\\ binary\\ treeperfect binary tree\n\n所有层的节点都被完全填满。\n在完美二叉树中，叶节点的度为 0，其余所有节点的度都为2\n若树的高度为 ℎ ，则节点总数为 2^ℎ+1^−1 ，呈现标准的指数级关系。\n\n\n\n完全二叉树 complete binary treecomplete\\ binary\\ treecomplete binary tree\n\n只有最底层的节点未被填满\n最底层节点尽量靠左填充。\n\n\n\n完满二叉树 full binary treefull\\ binary\\ treefull binary tree\n\n所有节点都有两个子节点（除了叶节点）。\n\n\n\n平衡二叉树 balanced binary treebalanced\\ binary\\ treebalanced binary tree\n\n任意节点的左子树和右子树的高度之差的绝对值不超过 1 。\n\n\n\n二叉树的退化\n​\t当二叉树的每层节点都被填满时，达到“完美二叉树”；而当所有节点都偏向一侧时，二叉树退化为“链表”。\n\n完美二叉树是理想情况，可以充分发挥二叉树“分治”的优势。\n链表则是另一个极端，各项操作都变为线性操作，时间复杂度退化至O(n)O(n)O(n)​。\n\n\n\n\n\n完美二叉树\n链表\n\n\n\n\n第iii层的节点数量\n2i−12^{i-1}2i−1\n111\n\n\n高度为hhh的树的叶节点数量\n2h−12^{h-1}2h−1\n111\n\n\n高度为hhh的树的节点总数\n2h−1−12^{h-1}-12h−1−1\nh+1h+1h+1\n\n\n节点总数为nnn的树的高度\nlog⁡2(n+1)−1\\log_{2}{(n+1)}-1log2​(n+1)−1\nn−1n-1n−1\n\n\n\n二叉搜索树 Binary Search Tree\n\n一棵 x.left.key≤\\le≤ x.right.key 的二叉树\n\n二叉树的遍历\n深度优先搜索 Depth-first traversal\n\n\n二叉树的遍历在「深度优先搜索 DFT」中分为三种：\n\n\n前序遍历\n\n\n中序遍历\n\n\n后续遍历\n\n\n\n\n\n代码实现\nINORDER-TREE-WALK(x) \tif x≠NIL \tINORDER-TREE-WALK(x.left) \tprint x.key\tINORDER-TREE-WALK(x.right)\n/* 前序遍历 */void preOrder(TreeNode *root) &#123;    if (root == nullptr)        return;    // 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树    vec.push_back(root-&gt;val);    preOrder(root-&gt;left);    preOrder(root-&gt;right);&#125;/* 中序遍历 */void inOrder(TreeNode *root) &#123;    if (root == nullptr)        return;    // 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树    inOrder(root-&gt;left);    vec.push_back(root-&gt;val);    inOrder(root-&gt;right);&#125;/* 后序遍历 */void postOrder(TreeNode *root) &#123;    if (root == nullptr)        return;    // 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点    postOrder(root-&gt;left);    postOrder(root-&gt;right);    vec.push_back(root-&gt;val);&#125;\n复杂度分析\n\n时间复杂度：Θ(n)\\Theta(n)Θ(n)\n\n对于渐进下界：\n​\t遍历需要访问 BSTBSTBST 的全部节点。所以有：\nT(n)=Ω(n)T(n)=\\Omega(n)\nT(n)=Ω(n)\n接下来证明渐进上界：\n​\t对于一棵空树，调用遍历函数需要一个极小的常数时间。所以设T(0)=cT(0)=cT(0)=c，ccc为常数​\n​\t对于一棵节点数n&gt;0n&gt;0n&gt;0 的树，设左子树节点数 k&gt;0k&gt;0k&gt;0 ，右子树节点数为 n−k−1n-k-1n−k−1 ，额外开销为ddd，则递归不等式为：\nT(n)≤T(k)+T(n−k−1)+d，d为常数T(n)\\le T(k)+T(n-k-1)+d，d为常数\nT(n)≤T(k)+T(n−k−1)+d，d为常数\n​\t我们不妨假设 ∃ c ∀ R\\exists{\\ c\\ \\forall\\ R}∃ c ∀ R ，当 ccc 很大时，有：T(n)≤cnT(n)\\le cnT(n)≤cn\n​\t则上式可化为：\nT(n)≤ck+c(n−k−1)+d=cn−(c−d)T(n) \\le ck+c(n-k-1)+d=cn-(c-d)\nT(n)≤ck+c(n−k−1)+d=cn−(c−d)\n​\t当 c−d≤0c-d\\le 0c−d≤0 时，有 T(n)=O(n)T(n)=O(n)T(n)=O(n)​ 。\n综上所述，==T(n)=Θ(n)T(n)=\\Theta (n)T(n)=Θ(n)==​​​\n\n空间复杂度：O(n)O(n)O(n)\n\n​\t在最差情况下，即树退化为链表时，递归深度达到 nnn ，系统占用  O(n)O(n)O(n)​ 栈帧空间。\n广度优先遍历 Breadth-first traversal\n\n「层序遍历 level-order traversal」\n\n​\t从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点。\n代码实现\n​\t广度优先遍历通常借助“队列”来实现。队列遵循“先进先出”的规则，而广度优先遍历则遵循“逐层推进”的规则，两者背后的思想是一致的。\n/* 层序遍历 */vector&lt;int&gt; levelOrder(TreeNode *root) &#123;    // 初始化队列，加入根节点    queue&lt;TreeNode *&gt; queue;    queue.push(root);    // 初始化一个列表，用于保存遍历序列    vector&lt;int&gt; vec;    while (!queue.empty()) &#123;        TreeNode *node = queue.front();        queue.pop();              // 队列出队        vec.push_back(node-&gt;val); // 保存节点值        if (node-&gt;left != nullptr)            queue.push(node-&gt;left); // 左子节点入队        if (node-&gt;right != nullptr)            queue.push(node-&gt;right); // 右子节点入队    &#125;    return vec;&#125;\n复杂度分析\n\n时间复杂度：Θ(n)\\Theta (n)Θ(n)​\n\n​\t所有节点被访问一次，使用 Θ(n)\\Theta (n)Θ(n) 时间，其中 nnn 为节点数量。\n\n空间复杂度：O(n)O(n)O(n)​\n\n​\t在最差情况下，即满二叉树时，遍历到最底层之前，队列中最多同时存在 (n+1)/2(n+1)/2(n+1)/2 个节点，占用 O(n)O(n)O(n) 空间。\n二叉搜索树的查找\n​\t给定目标节点值 num ，可以根据二叉搜索树的性质来查找。如图 7-17 所示，我们声明一个节点 cur ，从二叉树的根节点 root 出发，循环比较节点值 cur.val 和 num 之间的大小关系。\n\n若 cur.val &lt; num ，说明目标节点在 cur 的右子树中，因此执行 cur = cur.right 。\n若 cur.val &gt; num ，说明目标节点在 cur 的左子树中，因此执行 cur = cur.left 。\n若 cur.val = num ，说明找到目标节点，跳出循环并返回该节点。\n\n代码实现\n/* 查找节点 */TreeNode *search(int num) &#123;    TreeNode *cur = root;    // 循环查找，越过叶节点后跳出    while (cur != nullptr &amp;&amp; cur-&gt;val != num) &#123;        // 目标节点在 cur 的右子树中        if (cur-&gt;val &lt; num)            cur = cur-&gt;right;        // 目标节点在 cur 的左子树中        else            cur = cur-&gt;left;    &#125;    // 返回目标节点    return cur;&#125;\n最大关键字元素和最小关键字元素\n/* 最小关键字-迭代 */TreeNode *Minimun(TreeNode *x)&#123;\twhile(x-&gt;left != nullptr)        x = x-&gt;left;    return x;&#125;\n/* 最小关键字-递归 */TreeNode *Minimun(TreeNode *x)&#123;    if(x-&gt;left != nullptr)        return Minimun(x-&gt;left);    else        return x;&#125;\n/* 最大关键字 */TreeNode *Maximun(TreeNode *x)&#123;\twhile(x != nullptr)        x = x-&gt;right;    return x;&#125;\n/* 最大关键字-递归 */TreeNode *Maximun(TreeNode *x)&#123;    if(x-&gt;right != nullptr)        return Minimun(x-&gt;right);    else        return x;&#125;\n后继和前驱\n\nTREE-SUCCESSOR(x)\tif x.right ≠ NIL \t\treturn TREE-MINIMUM(x.right) \ty = x.p \twhile y ≠ NIL and x == y.right \t\tx = y \t\ty = y.p \treturn y\n/* c++版后继 */TreeNode *Successor(TreeNode *x)&#123;    //如果结点x的右子树非空，那么x的后继恰是x右子树中的最左结点    if(x-&gt;right != nullptr)        return Minimun(x-&gt;right);    TreeNode *y=x-&gt;prev;    //如果x的右子树为空并有一个后继，那么向上回溯直到**x节点**是其父节点的左孩子    while(y != nullptr &amp;&amp; x-&gt;val == y-&gt;right-&gt;val)&#123;        x = y;        y = y-&gt;prev;    &#125;    return y;&#125;\n/* c++版前驱 */TreeNode *Predecessor(TreeNode *x)&#123;    //如果结点x的左子树非空，那么x的前驱恰是x左子树中的最右结点    if(x-&gt;left != nullptr)        return Maximun(x-&gt;left);    TreeNode *y=x-&gt;prev;    //如果x的左子树为空并有一个前驱，那么向上回溯直到**x节点**是其父节点的右孩子    while(y != nullptr &amp;&amp; x-&gt;val == y-&gt;left-&gt;val)&#123;        x = y;        y = y-&gt;prev;    &#125;    return y;&#125;\n二叉搜索树的插入\n​\t给定一个待插入元素 num ，为了保持二叉搜索树“左子树 &lt; 根节点 &lt; 右子树”的性质，插入操作流程如下所示：\n\n查找插入位置：与查找操作相似，从根节点出发，根据当前节点值和 num 的大小关系循环向下搜索，直到越过叶节点（遍历至 None ）时跳出循环。\n在该位置插入节点：初始化节点 num ，将该节点置于 None 的位置。\n\n代码实现\n/* 伪代码 */TREE-INSERT(T,z) \ty = NIL\tx = T.root \twhile x ≠ NIL \t\ty = x \t\tif z.key &lt; x.key \t\t\tx = x.left\t\telse \t\t\tx = x. right \tz.p = y \tif y == NIL \t\tT. root= z \t\t// tree T was empty \telseif z.key &lt; y.key \t\ty.left= z \telse y.right = z\n/* 插入节点-迭代版 */void insert(int num) &#123;    // 若树为空，则初始化根节点    if (root == nullptr) &#123;        root = new TreeNode(num);        return;    &#125;    TreeNode *cur = root, *pre = nullptr;    // 循环查找，越过叶节点后跳出    while (cur != nullptr) &#123;        // 找到重复节点，直接返回        if (cur-&gt;val == num)            return;        pre = cur;        // 插入位置在 cur 的右子树中        if (cur-&gt;val &lt; num)            cur = cur-&gt;right;        // 插入位置在 cur 的左子树中        else            cur = cur-&gt;left;    &#125;    // 插入节点    TreeNode *node = new TreeNode(num);    if (pre-&gt;val &lt; num)        pre-&gt;right = node;    else        pre-&gt;left = node;&#125;\n/* 插入节点-递归版 */void insert(TreeNode* &amp;cur, int num) &#123;    // 如果当前节点为空，则创建新节点并返回    if (cur == nullptr) &#123;        cur = new TreeNode(num);        return;    &#125;    // 如果值已存在，则直接返回    if (cur-&gt;val == num)        return;    // 如果要插入的值比当前节点的值大，则插入到右子树中    if (cur-&gt;val &lt; num)        insert(cur-&gt;right, num);    // 如果要插入的值比当前节点的值小，则插入到左子树中    else        insert(cur-&gt;left, num);&#125;\n复杂度分析\n\n时间复杂度：O(log n)O(log\\ n)O(log n) ，n为节点数\n空间复杂度：O(1)O(1)O(1)\n\n二叉搜索树的删除\n​\t先在二叉树中查找到目标节点，再将其删除。与插入节点类似，我们需要保证在删除操作完成后，二叉搜索树的“左子树 &lt; 根节点 &lt; 右子树”的性质仍然满足。\n​\t因此，我们根据目标节点的子节点数量，分 0、1 和 2 三种情况，执行对应的删除节点操作。\n\n\n若 zzz 有0个子节点，则简单地将 zzz 删除，并修改 zzz 的父节点，用 NILNILNIL​ 作为孩子来替换 zzz 。\n\n\n若 zzz 有1个子节点，则将这个子节点提升到 zzz 的位置，并修改 zzz 的父节点，用 zzz 的孩子来替换 zzz 。（图a、b）\n\n\n若 zzz 有2个子节点，找 zzz 的后继 yyy ，然后 yyy 的右孩子（若有）取代 yyy 的位置，最后用 yyy 取代 zzz 。 （图c、d）\n\n\n\n\n\n\n代码实现\n/* 将以u为根的子树用以v为根的子树代替 */TRANSPLANT(T,u,v)\t/*若u为根节点*/\tif u.p == NIL \t\tT.root=v \t/*若u是其父节点的左孩子*/\telse if u == u.p.left\t\tu.p.left = v\t/*若u是其父节点的右孩子*/\telse\t\tu.p.right = v\tif v ≠ NIL\t\tv.p=u.p\n/* 删除结点z */TREE-DELETE(T,z)\t/* 若z没有左孩子-图a */\tif z.left == NIL\t\tTRANSPLANT(T,z,z.right) /* 以z的右子树代替z */\t/* 若z没有右孩子-图b */\telse if z.right == NIL\t\tTRANSPLANT(T,z,z.left) /* 以z的左子树代替z */\t/* z有两个孩子 */\telse\t\ty = TREE-MINIMUM(z.right) /* y为z的后继，y必然没有左节点 */\t\t/* 若y不是z的孩子-图d */\t\tif y.p ≠ z\t\t\tTRANSPLANT(T,y,y.right) /* 将y的位置替换为y的右子树 */\t\t\ty.right = z.right /* 将y的右子树设置为z的右子树 */\t\t\ty.right.p = y /* 将y的右子树的父节点设置为y */\t\t/* 若y是z的右孩子-图c 以及图d的后续 */\t\tTRANSPLANT(T,z,y) /* 用y替换z */\t\ty.left = z.left \t\ty.left.p = y\n/* 删除节点 */void remove(int num) &#123;    // 若树为空，直接提前返回    if (root == nullptr)        return;    TreeNode *cur = root, *pre = nullptr;    // 循环查找，越过叶节点后跳出    while (cur != nullptr) &#123;        // 找到待删除节点，跳出循环        if (cur-&gt;val == num)            break;        pre = cur;        // 待删除节点在 cur 的右子树中        if (cur-&gt;val &lt; num)            cur = cur-&gt;right;        // 待删除节点在 cur 的左子树中        else            cur = cur-&gt;left;    &#125;    // 若无待删除节点，则直接返回    if (cur == nullptr)        return;        // 子节点数量 = 0 or 1    if (cur-&gt;left == nullptr || cur-&gt;right == nullptr) &#123;        // 当子节点数量 = 0 or 1 时， child = nullptr or 该子节点        TreeNode *child = cur-&gt;left != nullptr ? cur-&gt;left : cur-&gt;right;        // 删除节点 cur        if (cur != root) &#123;            if (pre-&gt;left == cur)                pre-&gt;left = child;            else                pre-&gt;right = child;        &#125;         else &#123;            // 若删除节点为根节点，则重新指定根节点            root = child;        &#125;        // 释放内存        delete cur;    &#125;    // 子节点数量 = 2    else &#123;        // 获取中序遍历中 cur 的下一个节点        TreeNode *tmp = cur-&gt;right;        while (tmp-&gt;left != nullptr) &#123;            tmp = tmp-&gt;left;        &#125;        int tmpVal = tmp-&gt;val;        // 递归删除节点 tmp        remove(tmp-&gt;val);        // 用 tmp 覆盖 cur        cur-&gt;val = tmpVal;    &#125;&#125;\n复杂度分析\n\n时间复杂度：O(log n)O(log\\ n)O(log n) ，n为节点数\n空间复杂度：O(1)O(1)O(1)​\n\n*随机构建二叉搜索树 Randomly built binary search trees\n​\t定义 nnn​ 个关键字的一棵随机构建二叉搜索树为按随机次序插入这些关键字到一棵初始的空树中而生成的树，这里输入关键字的 n!n!n! 个排列中的每个都是等可能地出现。那么对于这棵树的期望高度，则有如下定理：\n\n定理\t一棵有 nnn 个不同关键字的随机构建二叉搜索树的期望高度为 ==O(log n)O(log\\ n)O(log n)== 。\n证明如下：\n\n​\t我们先定义如下三个随机变量：\n​\t\t1. XnX_{n}Xn​ 为一棵有 nnn 个不同关键字的随机构建二叉搜索树的高度。\n​\t\t2. Yn=2XnY_{n}=2^{X_{n}}Yn​=2Xn​ 为指数高度，定义 Y0=0Y_{0}=0Y0​=0 和 Y1=20=1Y_{1}=2^{0}=1Y1​=20=1 。\n​\t\t3. RnR_{n}Rn​ 为一个随机变量，选择一个关键字作为树根，其为这个关键字在 nnn 个关键字集合中的秩（rankrankrank），表示这个关键字在排好序后应占据的位置。RnR_{n}Rn​ 的值对于集合 {1,2,...,n}\\{1, 2,...,n\\}{1,2,...,n} 中的任何元素都是等可能的。\n​\t\t若 Rn=iR_{n}=iRn​=i ，那么根的左子树是一棵有 i−1i-1i−1 个关键字的随机构建二叉搜索树，并且右子树是一棵有 n−in-in−i 个关键字的随机构建搜二叉索树。\n​\t\t因为二叉树的高度为：\nXn=max(leftSubtree.height,rightSubtree.height)+1X_{n} =max(leftSubtree.height,rightSubtree.height)+1\nXn​=max(leftSubtree.height,rightSubtree.height)+1\n​\t\t所以有：\nYn=2⋅max(Yi−1,Yn−i)Y_{n}=2\\cdot max(Y_{i-1},Y_{n-i})\nYn​=2⋅max(Yi−1​,Yn−i​)\n​\t\t接下来，我们定义指示器随机变量（chapter 5.2chapter\\ 5.2chapter 5.2）Zn,1Z_{n,1}Zn,1​ ，Zn,2Z_{n,2}Zn,2​ ，......... ，Zn,nZ_{n,n}Zn,n​ ，其中：\nZn,i=I{Rn=i}={ 1n=i 0n≠i①Z_{n,i}=I\\{R_{n}=i\\}=\\begin{cases}\n\\ 1     &amp;n=i\\\\\n\\ 0     &amp;n\\ne i\n\\end{cases}\n\\qquad ①\nZn,i​=I{Rn​=i}={ 1 0​n=in=i​①\n​\t\t又因为 Rn=iR_{n}=iRn​=i 对于集合中每一个元素取值的概率是相同的，所以：\nP{Rn=i}=1n ,(i=1,2,...,n)②P\\{R_{n}=i\\}=\\frac{1}{n}\\ ,(i=1,2,...,n) \\qquad ②\nP{Rn​=i}=n1​ ,(i=1,2,...,n)②\n​\t\t结合 ① ②①\\ ②① ② ，得到：\nE[Zn,i]=1⋅P{Rn=i}=1n ,(i=1,2,...,n)③E[Z_{n,i}]=1 \\cdot P\\{R_{n}=i\\}=\\frac{1}{n} \\ ,(i=1,2,...,n) \\quad ③\nE[Zn,i​]=1⋅P{Rn​=i}=n1​ ,(i=1,2,...,n)③\n​\t\t由于 Zn,iZ_{n,i}Zn,i​ 恰有一个值为 111 ，其余所有值为 000 ，因此：\nYn=∑i=1nZn,i(2⋅max(Yi−1,Yn−i))Y_{n}=\\sum_{i=1}^{n}{Z_{n,i}(2\\cdot max(Y_{i-1},Y_{n-i}))}\nYn​=i=1∑n​Zn,i​(2⋅max(Yi−1​,Yn−i​))\n​\t\t由于 Zn,iZ_{n,i}Zn,i​ 独立于 Yi−1,Yn−iY_{i-1},Y_{n-i}Yi−1​,Yn−i​ 的值，上式两边取期望，得：\nE[Yn]=E[∑i=1nZn,i(2⋅max⁡(Yi−1,Yn−i))]=∑i=1nE[Zn,i(2⋅max⁡(Yi−1,Yn−i))](期望的线性性质)=∑i=1nE[Zn,i]⋅E[2⋅max⁡(Yi−1,Yn−i)](独立性)=∑i=1n1n⋅E[2⋅max⁡(Yi−1,Yn−i)](③式)=2n∑i=1nE[max⁡(Yi−1,Yn−i)](期望的线性性质)≤2n∑i=1n(E[Yi−1]+E[Yn−i])(补充证明1)\\begin{align*}\nE[Y_{n}] &amp;= E\\left[\\sum_{i=1}^{n}{Z_{n,i}(2 \\cdot \\max(Y_{i-1},Y_{n-i}))}\\right] \\\\\n&amp;=\\sum_{i=1}^{n}E[{Z_{n,i}}(2 \\cdot \\max(Y_{i-1},Y_{n-i}))] &amp;(期望的线性性质)\\\\\n&amp;=\\sum_{i=1}^{n}E[{Z_{n,i}}]\\cdot E[2 \\cdot \\max(Y_{i-1},Y_{n-i})] &amp;(独立性)\\\\\n&amp;=\\sum_{i=1}^{n}\\frac{1}{n}\\cdot E[2 \\cdot \\max(Y_{i-1},Y_{n-i})] &amp;(③式)\\\\\n&amp;=\\frac{2}{n}\\sum_{i=1}^{n}E[\\max(Y_{i-1},Y_{n-i})] &amp;(期望的线性性质)\\\\\n&amp;\\le\\frac{2}{n}\\sum_{i=1}^{n}(E[Y_{i-1}]+E[Y_{n-i}]) &amp;(补充证明1)\\\\\n\\end{align*}\nE[Yn​]​=E[i=1∑n​Zn,i​(2⋅max(Yi−1​,Yn−i​))]=i=1∑n​E[Zn,i​(2⋅max(Yi−1​,Yn−i​))]=i=1∑n​E[Zn,i​]⋅E[2⋅max(Yi−1​,Yn−i​)]=i=1∑n​n1​⋅E[2⋅max(Yi−1​,Yn−i​)]=n2​i=1∑n​E[max(Yi−1​,Yn−i​)]≤n2​i=1∑n​(E[Yi−1​]+E[Yn−i​])​(期望的线性性质)(独立性)(③式)(期望的线性性质)(补充证明1)​\n​\t\t因为 E[Y0]E[Y_{0}]E[Y0​] ，E[Y1]E[Y_{1}]E[Y1​]，......... ，E[Yn−1]E[Y_{n-1}]E[Yn−1​] 每一项各出现两次，一次作为 E[Yi−1]E[Y_{i-1}]E[Yi−1​] ，另一次为 E[Yn−1]E[Y_{n-1}]E[Yn−1​] 。\n​\t\t所以上述公式可化为：\nE[Yn]≤4n∑i=0n−1E[Yi]E[Y_{n}] \\le\\frac{4}{n}\\sum_{i=0}^{n-1}E[Y_{i}]\nE[Yn​]≤n4​i=0∑n−1​E[Yi​]\n​\t\t使用替换法，证明 E[Y(n)]=O(n3)E[Y(n)]=O(n^3)E[Y(n)]=O(n3) ：\n4n∑i=0n−1E[Yi]≤4n∑i=0n−1cn3≤4n⋅cn44=cn3\\begin{align*}\n\\frac{4}{n}\\sum_{i=0}^{n-1}E[Y_{i}] &amp;\\le \\frac{4}{n}\\sum_{i=0}^{n-1}cn^3\\\\\n&amp;\\le \\frac{4}{n} \\cdot \\frac{cn^4}{4}=cn^3\n\\end{align*}\nn4​i=0∑n−1​E[Yi​]​≤n4​i=0∑n−1​cn3≤n4​⋅4cn4​=cn3​\n​\t\t所以，E[Y(n)]=O(n3)E[Y(n)]=O(n^3)E[Y(n)]=O(n3) ，即E[2X(n)]=O(n3)E[2^{X(n)}]=O(n^3)E[2X(n)]=O(n3)。\n​\t\t由 JensenJensenJensen 不等式（补充证明2）：\n2E[X(n)]≤E[2X(n)]=O(n3)2^{E[X(n)]}\\le E[2^{X(n)}]=O(n^3)\n2E[X(n)]≤E[2X(n)]=O(n3)\n​\t\t两边取对数：\nE[X(n)]=O(lgn)E[X(n)]=O(lgn)\nE[X(n)]=O(lgn)\n​\t综上所述，一棵有 nnn 个不同关键字的随机构建二叉搜索树的期望高度为 ==O(log n)O(log\\ n)O(log n)​== 。\n\n补充证明1：\n要证明 E[max⁡(X,Y)]≤E[X]+E[Y]E[\\max(X,Y)] \\leq E[X] + E[Y]E[max(X,Y)]≤E[X]+E[Y]，我们可以考虑分两种情况：\n\n当 X≤YX \\leq YX≤Y 时，有 max⁡(X,Y)=Y\\max(X,Y) = Ymax(X,Y)=Y。\n当 X&gt;YX &gt; YX&gt;Y 时，有 max⁡(X,Y)=X\\max(X,Y) = Xmax(X,Y)=X。\n\n因此，我们可以写出以下不等式：\nE[max⁡(X,Y)]=E[max⁡(X,Y)∣X≤Y]⋅P(X≤Y)+E[max⁡(X,Y)∣X&gt;Y]⋅P(X&gt;Y)≤E[Y]⋅P(X≤Y)+E[X]⋅P(X&gt;Y)=E[Y⋅1X≤Y]+E[X⋅1X&gt;Y]\\begin{align*}\nE[\\max(X,Y)] &amp;= E[\\max(X,Y) \\mid X \\leq Y] \\cdot P(X \\leq Y) + E[\\max(X,Y) \\mid X &gt; Y] \\cdot P(X &gt; Y) \\\\\n&amp;\\leq E[Y] \\cdot P(X \\leq Y) + E[X] \\cdot P(X &gt; Y) \\\\\n&amp;= E[Y \\cdot \\mathbb{1}_{X \\leq Y}] + E[X \\cdot \\mathbb{1}_{X &gt; Y}]\n\\end{align*}\nE[max(X,Y)]​=E[max(X,Y)∣X≤Y]⋅P(X≤Y)+E[max(X,Y)∣X&gt;Y]⋅P(X&gt;Y)≤E[Y]⋅P(X≤Y)+E[X]⋅P(X&gt;Y)=E[Y⋅1X≤Y​]+E[X⋅1X&gt;Y​]​\n其中，1X≤Y\\mathbb{1}_{X \\leq Y}1X≤Y​ 和 1X&gt;Y\\mathbb{1}_{X &gt; Y}1X&gt;Y​ 是指示函数。现在，因为指示函数的期望是概率本身，所以我们有：\nE[Y⋅1X≤Y]=P(X≤Y)⋅E[Y]≤P(X≤Y)⋅E[X]+P(X≤Y)⋅E[Y]E[X⋅1X&gt;Y]=P(X&gt;Y)⋅E[X]≤P(X&gt;Y)⋅E[X]+P(X&gt;Y)⋅E[Y]E[Y \\cdot \\mathbb{1}_{X \\leq Y}] = P(X \\leq Y) \\cdot E[Y] \\leq P(X \\leq Y) \\cdot E[X] + P(X \\leq Y) \\cdot E[Y] \\\\\nE[X \\cdot \\mathbb{1}_{X &gt; Y}] = P(X &gt; Y) \\cdot E[X] \\leq P(X &gt; Y) \\cdot E[X] + P(X &gt; Y) \\cdot E[Y]\nE[Y⋅1X≤Y​]=P(X≤Y)⋅E[Y]≤P(X≤Y)⋅E[X]+P(X≤Y)⋅E[Y]E[X⋅1X&gt;Y​]=P(X&gt;Y)⋅E[X]≤P(X&gt;Y)⋅E[X]+P(X&gt;Y)⋅E[Y]\n将上述两个不等式代入前面的不等式中，我们得到：\nE[max⁡(X,Y)]≤E[Y]⋅P(X≤Y)+E[X]⋅P(X&gt;Y)≤E[X]+E[Y]E[\\max(X,Y)] \\leq E[Y] \\cdot P(X \\leq Y) + E[X] \\cdot P(X &gt; Y) \\leq E[X] + E[Y]\nE[max(X,Y)]≤E[Y]⋅P(X≤Y)+E[X]⋅P(X&gt;Y)≤E[X]+E[Y]\n因此，E[max⁡(X,Y)]≤E[X]+E[Y]E[\\max(X,Y)] \\leq E[X] + E[Y]E[max(X,Y)]≤E[X]+E[Y]​​，证毕。\n\n\n补充证明2：\n假设 fff 是一个 convexconvexconvex 函数（国外是凸函数，国内是凹函数）。我们想要证明对于任意随机变量 XXX 和权重 wiw_iwi​，满足 ∑iwi=1\\sum_{i} w_i = 1∑i​wi​=1，有：\nE[f(X)]≥f(E[X])E[f(X)] \\geq f(E[X])\nE[f(X)]≥f(E[X])\n为了证明这一点，我们首先需要定义 convexconvexconvex 函数的性质。一个函数 fff 被称为 convexconvexconvex 函数，如果对于任意 x1,x2x_1, x_2x1​,x2​ 和 0≤λ≤10 \\leq \\lambda \\leq 10≤λ≤1，都有：\nf(λx1+(1−λ)x2)≤λf(x1)+(1−λ)f(x2)f(\\lambda x_1 + (1 - \\lambda) x_2) \\leq \\lambda f(x_1) + (1 - \\lambda) f(x_2)\nf(λx1​+(1−λ)x2​)≤λf(x1​)+(1−λ)f(x2​)\n现在，我们来证明 Jensen 不等式：\n根据 convexconvexconvex 函数的定义，我们有：\nf(λE[X]+(1−λ)E[X])≤λf(E[X])+(1−λ)f(E[X])f(\\lambda E[X] + (1 - \\lambda) E[X]) \\leq \\lambda f(E[X]) + (1 - \\lambda) f(E[X])\nf(λE[X]+(1−λ)E[X])≤λf(E[X])+(1−λ)f(E[X])\n⇒f(E[X])≤λf(E[X])+(1−λ)f(E[X])\\Rightarrow f(E[X]) \\leq \\lambda f(E[X]) + (1 - \\lambda) f(E[X])\n⇒f(E[X])≤λf(E[X])+(1−λ)f(E[X])\n⇒f(E[X])≤f(E[X])\\Rightarrow f(E[X]) \\leq f(E[X])\n⇒f(E[X])≤f(E[X])\n这是显然成立的。因此，我们得出：\nE[f(X)]≥f(E[X])E[f(X)] \\geq f(E[X])\nE[f(X)]≥f(E[X])\n这就证明了 Jensen 不等式。\n\n:sweat_smile: 红黑树 Red-Black Tree :fearful:\n\n🥵Q宝速速给我抄抄😋\n\n红黑树的性质\n\n每个节点要么红，要么黑\n根节点永远为黑\n叶节点 (NIL)(NIL)(NIL) 为黑\n不会有两个相连的红节点（一个节点是红的，那么俩子节点是黑的）\n对每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点（即黑高 bh(x)bh(x)bh(x) 相同）\n(*)每一棵红黑树都对应着一棵 2−3−42-3-42−3−4 树（或 2−32-32−3 树）\n\n\n其最明显的优势：一棵有 nnn 个节点的红黑树的高度至多为 ==2log(n+1)2log( n+1)2log(n+1)==​ 。\n\n证明如下：\n​\t设 xxx 为一棵红黑树的根节点，bh(x)bh(x)bh(x)​ 为一棵红黑树某个节点的黑高（即一条简单路径上黑色节点的个数），hhh 为一棵红黑树的高度。\n​\t我们先证明以 xxx 为根的子树中至少包含 2bh(x)−12^{bh(x)}-12bh(x)−1 个内部节点\n​\t要证明此点，我们以数学归纳法进行证明：\n​\t\t1. 当 x.depth=0x.depth=0x.depth=0 ，即 xxx 为根节点，此时子树中的节点满足 2bh(x)−1=20−1=02^{bh(x)}-1=2^{0}-1=02bh(x)−1=20−1=0​ 。\n​\t\t2. 当 x.depth=kx.depth=kx.depth=k ，假设该命题成立，即以 xxx 为根的子树中至少包含 2bh(xk)−12^{bh(x_{k})}-12bh(xk​)−1 个内部节点，此时的黑高为 bh(xk)bh(x_{k})bh(xk​) 或 bh(xk)−1bh(x_{k})-1bh(xk​)−1 ，这取决于 x.colorx.colorx.color 是黑还是红。\n​\t\t**3. **则当 x.depth=k+1x.depth=k+1x.depth=k+1 ，即 xxx​ 下一节点时，因为同一节点左右子树的黑高一致，所以有：\nbh(xk+1)=bh(xk)−1bh(x_{k+1})=bh(x_{k})-1\nbh(xk+1​)=bh(xk​)−1\n​\t\t\t此时 x.depth=kx.depth=kx.depth=k 的左右子树节点数至少为：2bh(xk+1)−1=2bh(xk)−1−12^{bh(x_{k+1})}-1=2^{bh(x_{k})-1}-12bh(xk+1​)−1=2bh(xk​)−1−1 。\n​\t\t\t所以内部总节点数至少为：(2bh(xk)−1−1)+(2bh(xk)−1−1)+1=2bh(xk)−1(2^{bh(x_{k})-1}-1)+(2^{bh(x_{k})-1}-1)+1=2^{bh(x_{k})}-1(2bh(xk​)−1−1)+(2bh(xk​)−1−1)+1=2bh(xk​)−1 。\n​\t\t\t（这里只加一次 111 是因为考虑到了左右子树可能存在 NILNILNIL ）\n​\t\t综上所述，以 xxx 为根的子树中至少包含 ==2bh(x)−12^{bh(x)}-12bh(x)−1== 个内部节点。\n​\t又因为根节点到叶节点至少有一半是黑节点，所以黑高至少为 ⌈h/2⌉\\left\\lceil h/2\\right\\rceil⌈h/2⌉ ，于是有：\nn≥2⌈h/2⌉−1n \\ge 2^{\\left\\lceil h/2\\right\\rceil}-1\nn≥2⌈h/2⌉−1\n​\t两边取对：\nlog(n+1)≥⌈h/2⌉log(n+1) \\ge \\left\\lceil h/2\\right\\rceil\nlog(n+1)≥⌈h/2⌉\n​\t即：\nh≤2log(n+1)h\\le 2log(n+1) \nh≤2log(n+1)\n红黑树的旋转\n在 CS61BCS61BCS61B​ 上，旋转的正式定义为：\n\nrotateLeft(G) : Let x be the right child of G. Make G the new left child of x.\n\n左旋：设 xxx 为 GGG 的右子结点，让 GGG 成为 xxx 的新左子结点。\n\n\nrotateRight(G): Let x be the left child of G. Make G the new right child of x.\n\n右旋：设 xxx 为 GGG 的左子结点，让 GGG 成为 xxx 的新右子结点。\n\n\n\n\n上面发生的事情的书面描述是这样的：\n\nGGG 的右子项 PPP 与 GGG 合并，并带来了它的孩子。\n然后 PPP 将其左子项传递给 GGG，GGG 向左下降成为 PPP 的左子项。\n\n可以看到树的结构及其高度发生了变化。我们也可以在非根节点上轮换。我们只是暂时断开节点与父节点的连接，旋转节点上的子树，然后重新连接新的根。\n代码实现\n/* 伪代码-左旋 */LEIT-ROTATE(T,x) \ty = x.right \tx.right = y.left \tif y.left ≠ T.nil\t\ty.left.p = x\ty.p = x.p \tif x.p == T.nil /* 根节点 */\t\tT.root=y \telse if x == x.p.left \t\tx.p.left = y \telse x.p.right = y \ty.left= x \tX.p = y\n/* cs61b-java版 *//* 建议结合图来分析代码 */// make a right-leaning link lean to the leftprivate Node rotateLeft(Node h) &#123;    // assert (h != null) &amp;&amp; isRed(h.right);    Node x = h.right;     //将x设为h的右节点    h.right = x.left;     //将h的右节点设为x的左节点(即h.left.right)    x.left = h;           //将x的左节点设为h    return x;             //返回旋转后的根节点&#125;private Node rotateRight(Node h) &#123;    // assert (h != null) &amp;&amp; isRed(h.left);    Node x = h.left;    h.left = x.right;    x.right = h;    return x;&#125;\n/* c++版 */TreeNode *rotateLeft(TreeNode *h)&#123;    TreeNode *child = h-&gt;right;    h-&gt;right = child-&gt;left;    child-&gt;left = h;    return x;&#125;TreeNode *rotateRight(TreeNode *h)&#123;    TreeNode *child = h-&gt;left;    h-&gt;left = child-&gt;right;    child-&gt;right = h;    return x;&#125;\n复杂度分析\n\n\n时间复杂度：O(1)O(1)O(1)\n\n\n空间复杂度：O(1)O(1)O(1)\n\n\n红黑树的插入\n插入操作与 BSTBSTBST​ 基本一致。只是将插入节点染成红色，接着调用 RBT−Insert−FixupRBT-Insert-FixupRBT−Insert−Fixup 函数，修复红黑树的性质。\n代码实现\nRB-INSERT(T,z)\ty = T.nil\tx = T.root\twhile x != T.nil \t\ty = x \t\tif z. key &lt; x. key \t\t\tx = x.left \t\telse\t\t\tx = x.right \tz.p = y\tif y == T.nil \t\tT.root= z \telseif z.key &lt; y.key \t\ty.left = z \telse\t\ty.right = z\t/* 以上是BST-Insert操作 */\tz.left = T.nil\tz.right = T.nil\tz.color = RED\tRB-INSERT-FIXUP(T,z)\nfixupfixupfixup 原理分析\n接下来我们来分析一下 FixupFixupFixup​ 的原理：\n​\t执行 InsertInsertInsert 操作后，针对 RBTRBTRBT 的五个性质，我们不难发现：\n​\t\t性质 111 和性质 333 以及性质 555 依然成立\n​\t\t可能被破坏的是\n​\t\t\t性质 222 （根节点为黑色）\n​\t\t\t性质 444 （不会有两个相连的红节点）\n​\t\t\t并且这两个性质至多只有一条被破坏。\n​\t因此我们从修复性质 444 入手，确定循环终止条件，即 zzz 的父节点是黑色时终止。\n​\t接下来我们以 z.pz.pz.p 是左孩子为例，右孩子的代码直接所有方向取反。\n​\t此时，有如下 333​ 种情况：\n​\t\tcase1case1case1：zzz 的叔节点 yyy 是红色的\n​\t\t\t该情况在 zzz 和 z.pz.pz.p 都是红色时发生。因为 z.p.pz.p.pz.p.p 是黑色的，所以我们把 z.pz.pz.p 和 yyy 染成黑色，把 z.p.pz.p.pz.p.p 染成红色以保持性质 555 。然后我们以 z.p.pz.p.pz.p.p 作为新的 zzz 节点来重复循环（即 zzz 上移两个节点）。\n\n​\t\tcase2case2case2：zzz 的叔结点 yyy 是黑色的且 zzz 是一个右孩子（ zzz 和其父节点方向相反）\n​\t\tcase3case3case3：zzz 的叔结点 yyy 是黑色的且 zzz 是一个左孩子（ zzz 和其父节点方向一致）\n​\t\t\t我们将情况 222 和 333​ 合并在一起来看。\n​\t\t\t对于情况 222 ，我们立即对 z.pz.pz.p 执行一次左旋，将其转变为情况 333 。\n​\t\t\t对于情况 333 ，我们能肯定的是，z.p.pz.p.pz.p.p 必定为黑色。为了修复性质，我们交换 z.pz.pz.p 和z.p.pz.p.pz.p.p 的颜色，并对 z.p.pz.p.pz.p.p 执行一次右旋。此时，z.pz.pz.p 的颜色是黑色，循环终止，修复成功。\n\n\nfixupfixupfixup 代码\nRB-INSERT-FIXUP(T,z) \twhile z.p.color == RED \t\tif z.p == z.p.p.left \t\t\ty = z.p.p.right /* y是z的叔节点 */\t\t\t/* case1 */\t\t\tif y.color == RED \t\t\t\tz.p.color = BLACK \t\t\t\ty.color = BLACK \t\t\t\tz.p.p.color = RED \t\t\t\tz = z.p.p \t\t\telse\t\t\t\t/* case2 */\t\t\t\tif z == z. p. right \t\t\t\t\tz = z.p \t\t\t\t\tLEFT-ROTATE(T,z)\t\t\t\t/* case3 */\t\t\t\tz.p.color = BLACK \t\t\t\tz.p.p.color = RED \t\t\t\tRIGHT-ROTATE(T,z.p.p)\t\telse(same as then clause with &quot;right&quot; and &quot;left&quot; exchanged)\t\t\t......\tT.root.color= BLACK\n复杂度分析\n\n时间复杂度：O(log n)O(log\\ n)O(log n)​\n\n树高为 O(log n)O(log\\ n)O(log n) ，则插入操作需要 O(log n)O(log\\ n)O(log n) 的时间\n调用 FixupFixupFixup 时，仅当情况 111 发生时，zzz 才会沿树上升两层，此时需要O(log n)O(log\\ n)O(log n) 的时间，其他情况都是 O(1)O(1)O(1) 。\n因此是 O(log n)O(log\\ n)O(log n)\n\n\n空间复杂度：O(1)O(1)O(1)\n\n红黑树的删除\n删除操作跟 BSTBSTBST 的删除操作类似，只是多了一个记录节点 xxx 以及在最后添加了一个 RBT−Delete−FixupRBT-Delete-FixupRBT−Delete−Fixup 的操作\n代码实现\n/* 参考BST的删除 *//* 用以v为根的子树替换以u为根的子树 */RB-TRANSPLANT(T, u, v) \tif u.p == T.nil  /* 若u为根节点 */\t\tT.root=v \telse if u == u.p.left  /* 若u是其父节点的左孩子 */\t\tu.p.left = v  \telse  /* 若u是其父节点的右孩子 */\t\tu.p.right = v \tv.p = u.p\n/* 参考BST的删除 *//* attention:第9、13、24行传递的第三个参数与x相同，x只是引用作用，不参与实际删除操作，只是给后续的fixup操作提供参数 */RB-DELETE(T, z) \ty = z \ty-original-color = y.color \t/* 若z的左树为空 */\tif z.left == T.nil \t\tx = z.right \t\tRB-TRANSPLANT(T, z, z.right)  /* 用z的右孩子代替z */\t/* 若z的右树为空 */\telse if z.right == T.nil \t\tx = z.left \t\tRB-TRANSPLANT(T, z, z.left)   /* 用z的左孩子代替z */\t/* 若z有两个孩子 */\telse \t\ty = TREE-MINIMUM(z.right)     /* y是z的后继 */\t\ty-original-color = y.color \t\tx = y.right\t\t/* 若y是z的孩子 */\t\tif y.p == z \t\t\tx.p = y\t\t/* 若y不是z的孩子 */\t\telse\t\t\tRB-TRANSPLANT(T, y, y.right)  /* 用y的右孩子代替y */\t\t\ty.right = z.right             /* 令z的右孩子 */\t\t\ty.right.p = y                 /* 成为y的右孩子 */\t\tRB-TRANSPLANT(T, z, y)        /* 用后继y代替z */\t\ty.left = z.left               /* 将z的左孩子给 */\t\ty.left.p = y                  /* (肯定)没有左孩子的y */\t\ty.color = z.color\tif y-original-color == BLACK      /* y是红的不用管 不会影响红黑树的性质 */\t\tRB-DELETE-FIXUP(T, x)\nfixupfixupfixup 原理分析\n下面重点讲 FixupFixupFixup 的原理：\n​\t记录节点 xxx ，其为我们替换 yyy 所需的节点。\n​\t因为其引用的节点替换 yyy 后可能会违反红黑树的性质，所以我们要对 xxx 及其子树向上进行 FixupFixupFixup 操作。\n​\t如果 yyy 是黑色的话，会产生三个问题：\n​\t\t1. 若 yyy 是原先的根节点，而其一个红色的孩子代替了 yyy ，则会违反==性质2==，即根节点不能为红色。\n​\t\t2. 若 xxx 和 x.px.px.p 是红色的话，则违反了==性质4==，即两个红色节点不能相连。\n​\t\t**3. **若移动 yyy 后导致之前包含 yyy 的简单路径的 bh(x)bh(x)bh(x) 少了 111 ，则 yyy 的任何祖先都不满足性质5，即 bh(x)bh(x)bh(x) 相等。\n​\t\t\t解决这一问题的方法就是将现在占有 yyy 原先位置的 xxx 视作还有额外一层黑色，即黑黑色或红黑色。\n​\t\t\t（但 x.colorx.colorx.color​ 不变，只是视作有两种颜色，这里则变为违反==性质1==，但是后面会进行修复）\n​\t所以问题转变为 FixupFixupFixup 操作需要修复性质 1、2、41、2、41、2、4 。\n​\twhilewhilewhile 循环的目标就是要把额外的黑色沿树上移，直到：\n​\t\t1. xxx​​ 指向红黑节点，此时将其染成单个黑色\n​\t\t2. xxx 指向根节点，此时可以简单地&quot;移除&quot;额外的黑色\n​\t\t3. 执行适当的旋转及重新染色，退出循环\n​\t在循环里， xxx 是黑黑色的~~（如果是红黑色，那就直接染成黑色了，瞎进什么循环）~~，下面设 xxx 是其父节点左孩子， www 是 xxx 的兄弟节点。\n则会有如下几种情况：\n​\tcase1case1case1：xxx 的兄弟节点 www 是红色的  兄弟兄弟，你怎么是红色的(疾旋鼬.jpg)\n​\t\t因为 www 是红色，其必有俩黑色子节点，所以可以改变 www 以及 w.pw.pw.p 的颜色，并做一次旋转。\n​\t\t这样就将 case1case1case1 转换为接下来的三种情况处理。\n\n​\tcase2case2case2：xxx 的兄弟节点 www 是黑色的且 www​ 的两个孩子都是黑色\n​\t\t因为 www 是黑色的，所以从 xxx 和 www 上各去掉一层黑色，即 www 变为红色，xxx 上移。为补偿删掉的一层黑色，将新的 xxx 加一层黑色，继续循环，直到满足条件。\n​\t\t若从 case1case1case1 过来的，此时新的 xxx 是红黑色的，满足条件，直接将新的 xxx​ 染成黑色，结束循环，修复完成。\n\n​\tcase3case3case3：xxx 的兄弟节点 www 是黑色的且 www​ 的右节点是黑色，左节点是红色\n​\t\t此情况需要转换为 case4case4case4 来解决，所以我们先交换 www 和 w.leftw.leftw.left 的颜色，然后对 www 进行右旋。\n​\tcase4case4case4：xxx 的兄弟节点 www 是黑色的且 www 的右节点是红色\n​\t\t此情况下，将 w.rightw.rightw.right 变为黑色，x.px.px.p 与 www 交换颜色，并对 x.px.px.p 进行一次左旋，消除 xxx 的额外黑色，最后将 xxx 设为根节点，跳出循环。（ xxx 的那一层黑色给到了原来 www​ 的右节点）\n\nfixupfixupfixup 代码\nRB-DELETE-FIXUP(T, x) \twhile x != T. root and x.color == BLACK \t\tif x == x.p.left \t\t\tw = x.p.right \t\t\t/* case1 */\t\t\tif w.color == RED \t\t\t\tw.color = BLACK \t\t\t\tx.p.color = RED \t\t\t\tLEFT-ROTATE(T, x.p) \t\t\t\tw = x.p.right \t\t\t/* case2 */\t\t\tif w.left.color == BLACK and w.right.color == BLACK \t\t\t\tw.color = RED \t\t\t\tx = x.p\t\t\telse \t\t\t/* case3 */\t\t\tif w.right.color == BLACK \t\t\t\tw.left.color = BLACK \t\t\t\tw.color = RED \t\t\t\tRIGHT-ROTATE(T,w) \t\t\t\tw = x.p.right\t\t\t/* case4- */\t\t\tw.color = x.p.color \t\t\tx.p.color = BLACK \t\t\tw.right.color = BLACK \t\t\tLEFT-ROTATE(T, x.p) \t\t\tx = T.root \t\telse (same as then clause with &quot;right&quot; and &quot;left&quot; exchanged) \t\t\t......\tx.color = BLACK\n复杂度分析\n\n\n时间复杂度：O(log n)O(log\\ n)O(log n) ​\n\n不调用 FixupFixupFixup 时需要 O(log n)O(log\\ n)O(log n) ，因为树高是 O(log n)O(log\\ n)O(log n)\n而调用FixupFixupFixup ，case1、3、4case1、3、4case1、3、4 进行常数次数操作，case2case2case2 至多循环到根节点，也即树高 O(log n)O(log\\ n)O(log n) ​\n因此是 O(log n)O(log\\ n)O(log n)\n\n\n\n空间复杂度：O(1)O(1)O(1)\n\n\nB树 B-tree\n\n未完工喵~:yum:\nshmmshmmshmm 速速🤺\n\n","categories":["DataStru&Algo"],"tags":["Data Structure","Algorithm","SCNU Turing Discussion","BST","RBT"]}]